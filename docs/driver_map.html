<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cardiff EV Charging – Driver View (Traffic + Best ETA)</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #map { height: 100%; width: 100%; }
    /* IMPORTANT: prevent global CSS from breaking Google tiles */
    #map img { max-width: none !important; }

    .panel{
      position:absolute; top:12px; left:12px; z-index:5;
      background:rgba(255,255,255,0.96);
      border:1px solid #ddd; border-radius:12px;
      padding:12px 12px; width:360px;
      box-shadow:0 6px 22px rgba(0,0,0,0.14);
    }
    .title { font-size: 18px; font-weight: 750; margin: 2px 0 10px; }
    .small{ color:#374151; font-size:12px; }
    .hint{ margin-top:6px; font-size:12px; color:#6b7280; line-height: 1.35; }

    .row{ display:flex; gap:8px; margin:8px 0; align-items:center; }
    input[type="text"]{
      flex:1; padding:10px 10px; border-radius:10px; border:1px solid #d1d5db;
      outline:none; font-size:14px;
    }
    .btn{
      background:#111827; color:#fff; border:none; border-radius:10px;
      padding:10px 12px; cursor:pointer; font-size:13px; font-weight:600;
    }
    .btn.secondary{ background:#6b7280; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }

    .section { margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee; }
    .check { display:flex; align-items:center; gap:8px; margin:6px 0; }
    .check input { transform: translateY(1px); }

    .status { margin-top:8px; font-size:12px; color:#111827; white-space:pre-wrap; }

    .chips { display:flex; gap:8px; margin-top:8px; }
    .chip{
      border:1px solid #e5e7eb; background:#fff; border-radius:999px; padding:6px 10px;
      cursor:pointer; font-size:12px; font-weight:600; color:#111827;
    }
    .chip.active{ background:#111827; color:#fff; border-color:#111827; }

    .list { margin-top:10px; max-height: 260px; overflow:auto; border:1px solid #eee; border-radius:12px; }
    .item{
      padding:10px 10px; border-bottom:1px solid #f1f5f9;
      cursor:pointer; background:#fff;
    }
    .item:hover { background:#f8fafc; }
    .item:last-child { border-bottom:none; }
    .item .top { display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .item .name { font-weight:700; font-size:13px; }
    .item .meta { font-size:12px; color:#374151; margin-top:4px; line-height:1.25; }
    .badge {
      font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #e5e7eb;
      color:#111827; background:#fff;
    }
    .badge.good { border-color:#bbf7d0; background:#f0fdf4; }
    .badge.warn { border-color:#fed7aa; background:#fff7ed; }

    .legend { margin-top: 10px; font-size: 12px; }
    .swatch{ display:inline-block; width:10px; height:10px; border-radius:2px; margin-right:6px; border:1px solid rgba(0,0,0,0.2); }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panel">
    <div class="title">Driver view (Cardiff only)</div>

    <!-- Search -->
    <div class="row">
      <input id="q" type="text" placeholder="Search an address/place in Cardiff…" />
      <button id="btnSearch" class="btn">Search</button>
    </div>

    <div class="row">
      <button id="btnMyLoc" class="btn secondary">Use my location</button>
      <button id="btnRecommend" class="btn" disabled>Recommend best chargers (ETA)</button>
    </div>

    <div class="section">
      <div class="check"><input id="lyTraffic" type="checkbox" checked><label for="lyTraffic">Live traffic</label></div>
      <div class="check"><input id="lySupply" type="checkbox" checked><label for="lySupply">Existing chargers</label></div>
      <div class="check"><input id="lyPlanned" type="checkbox"><label for="lyPlanned">Planned new sites (future)</label></div>
      <div class="check"><input id="lyLSOA" type="checkbox"><label for="lyLSOA">LSOA boundary (optional)</label></div>

      <div class="hint">
        Tip: traffic lines are clearer at zoom ≥ 12. Driver map is locked to Cardiff bounds.
      </div>
    </div>

    <div class="section">
      <div class="small"><b>Best options</b> <span id="count" class="badge">0</span></div>
      <div class="chips">
        <div id="sortEta" class="chip active">Sort: ETA</div>
        <div id="sortDist" class="chip">Sort: Distance</div>
      </div>
      <div id="list" class="list">
        <div class="item" style="cursor:default;">
          <div class="name">No results yet.</div>
          <div class="meta">Set origin (search / my location) → Recommend.</div>
        </div>
      </div>
    </div>

    <div id="status" class="status"></div>

    <div class="legend">
      <div><span class="swatch" style="background:#2563eb;"></span><b>Blue</b>: existing chargers (bigger + ⚡)</div>
      <div><span class="swatch" style="background:#ef4444;"></span><b>Red</b>: planned sites (future) (optional)</div>
      <div><span class="swatch" style="background:#93c5fd;"></span>LSOA boundary fill (optional)</div>
    </div>
  </div>

<script>
  // ====== PUT YOUR KEY HERE ======
  const GMAPS_KEY = "AIzaSyAUproFl8jRStUlFwOKbQ8yh2CjNJ_H2c4";

  // GitHub Pages relative base
  const BASE = new URL("./", window.location.href);

  // Data files (must be reachable under docs/)
  const DATA_URLS = {
    lsoa:   new URL("data/processed/demand_lsoa_cardiff_exact.geojson", BASE).href,
    supply: new URL("data/processed/supply_chargers_ocm.geojson", BASE).href,
    planned:new URL("data/processed/new_sites_p10.geojson", BASE).href
  };

  // Cardiff bounds (slightly padded)
  const CARDIFF_BOUNDS = { west: -3.50, east: -2.85, south: 51.33, north: 51.62 };
  const CARDIFF_CENTER = { lat: 51.4816, lng: -3.1791 };

  // UI config
  const MAX_STRAIGHTLINE_CANDIDATES = 40; // pre-filter to avoid too many API calls
  const TOP_N = 10;

  // Map globals
  let map, info, trafficLayer;
  let lsoaLayer;
  let supplyMarkers = [];
  let plannedMarkers = [];
  let supplyFeatures = []; // keep features for recommendation
  let plannedFeatures = [];

  // Origin & route
  let originMarker = null;
  let originLatLng = null;

  let directionsService, directionsRenderer;
  let distanceMatrixService, geocoder;

  // Sorting
  let sortMode = "eta"; // "eta" or "dist"
  let lastResults = []; // cached recommend results

  // Marker highlight
  let highlightedId = null;

  function setStatus(msg) {
    document.getElementById("status").textContent = msg || "";
  }

  function setCount(n) {
    document.getElementById("count").textContent = String(n ?? 0);
  }

  async function loadGeoJSON(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${url}`);
    return await res.json();
  }

  function withinCardiff(latLng) {
    return (
      latLng.lat() >= CARDIFF_BOUNDS.south &&
      latLng.lat() <= CARDIFF_BOUNDS.north &&
      latLng.lng() >= CARDIFF_BOUNDS.west &&
      latLng.lng() <= CARDIFF_BOUNDS.east
    );
  }

  function setMarkersVisible(markers, on) {
    for (const m of markers) m.setMap(on ? map : null);
  }

  function circleIcon(fillColor, scale, labelText=null) {
    // Use normal Marker with circle symbol + optional label
    return {
      icon: {
        path: google.maps.SymbolPath.CIRCLE,
        fillColor,
        fillOpacity: 0.95,
        strokeColor: "#ffffff",
        strokeOpacity: 1,
        strokeWeight: 2,
        scale
      },
      label: labelText ? {
        text: labelText,
        color: "#ffffff",
        fontWeight: "800",
        fontSize: "10px"
      } : undefined
    };
  }

  function plannedIcon() {
    return {
      path: google.maps.SymbolPath.BACKWARD_CLOSED_ARROW,
      fillColor: "#ef4444",
      fillOpacity: 0.95,
      strokeColor: "#ffffff",
      strokeWeight: 2,
      scale: 7
    };
  }

  function setOrigin(latLng, label="Origin") {
    originLatLng = latLng;
    if (!originMarker) {
      originMarker = new google.maps.Marker({
        position: latLng,
        map,
        title: label,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          fillColor: "#111827",
          fillOpacity: 0.95,
          strokeColor: "#ffffff",
          strokeWeight: 2,
          scale: 7
        }
      });
    } else {
      originMarker.setPosition(latLng);
      originMarker.setMap(map);
    }

    map.panTo(latLng);
    map.setZoom(Math.max(map.getZoom(), 12));

    document.getElementById("btnRecommend").disabled = false;
    setStatus("Origin set. Click “Recommend best chargers (ETA)”.");
  }

  function getProp(p, keys) {
    if (!p) return "";
    for (const k of keys) {
      if (p[k] !== undefined && p[k] !== null && String(p[k]).trim() !== "") return String(p[k]);
    }
    return "";
  }

  function addSupplyMarkers(geojson) {
    const feats = geojson.features || [];
    supplyFeatures = feats;

    const markers = [];
    for (let i=0; i<feats.length; i++) {
      const f = feats[i];
      if (!f.geometry || f.geometry.type !== "Point") continue;
      const [lng, lat] = f.geometry.coordinates || [];
      if (typeof lat !== "number" || typeof lng !== "number") continue;

      const name = getProp(f.properties, ["name","Name","title","Title","operator","Operator","AddressInfo.Title"]) || "Existing charger";
      const id = getProp(f.properties, ["id","ID","ocm_id","OCM_ID"]) || `supply_${i}`;

      const marker = new google.maps.Marker({
        position: { lat, lng },
        map,
        title: name,
        ...circleIcon("#2563eb", 8, "⚡")
      });

      marker.__id = id;
      marker.__kind = "supply";
      marker.__feature = f;

      marker.addListener("click", () => {
        highlightMarker(id);
        const dest = marker.getPosition();
        const gmapsLink = `https://www.google.com/maps/dir/?api=1&destination=${dest.lat()},${dest.lng()}`;
        info.setContent(
          `<b>${escapeHtml(name)}</b><br/>Existing charger<br/>` +
          `<a href="${gmapsLink}" target="_blank" rel="noopener">Open in Google Maps</a>`
        );
        info.open(map, marker);

        // allow quick route preview if origin exists
        if (originLatLng) previewRoute(originLatLng, dest);
      });

      markers.push(marker);
    }
    return markers;
  }

  function addPlannedMarkers(geojson) {
    const feats = geojson.features || [];
    plannedFeatures = feats;

    const markers = [];
    for (let i=0; i<feats.length; i++) {
      const f = feats[i];
      if (!f.geometry || f.geometry.type !== "Point") continue;
      const [lng, lat] = f.geometry.coordinates || [];
      if (typeof lat !== "number" || typeof lng !== "number") continue;

      const sid = getProp(f.properties, ["site_id","id","chosen_candidate_id"]) || `planned_${i}`;
      const marker = new google.maps.Marker({
        position: { lat, lng },
        map: null, // default OFF
        title: `Planned site: ${sid}`,
        icon: plannedIcon()
      });
      marker.__id = sid;
      marker.__kind = "planned";
      marker.__feature = f;

      marker.addListener("click", () => {
        const dest = marker.getPosition();
        info.setContent(`<b>Planned new site (future)</b><br/>id: ${escapeHtml(sid)}`);
        info.open(map, marker);
      });

      markers.push(marker);
    }
    return markers;
  }

  function highlightMarker(id) {
    // reset previous
    if (highlightedId && highlightedId !== id) {
      const prev = supplyMarkers.find(m => m.__id === highlightedId);
      if (prev) prev.setOptions(circleIcon("#2563eb", 8, "⚡"));
    }
    highlightedId = id;
    const m = supplyMarkers.find(x => x.__id === id);
    if (m) {
      // make it even more obvious
      m.setOptions(circleIcon("#1d4ed8", 11, "⚡"));
      map.panTo(m.getPosition());
    }
  }

  function initLayersUI() {
    const lyTraffic = document.getElementById("lyTraffic");
    const lySupply  = document.getElementById("lySupply");
    const lyPlanned = document.getElementById("lyPlanned");
    const lyLSOA    = document.getElementById("lyLSOA");

    lyTraffic.addEventListener("change", () => trafficLayer.setMap(lyTraffic.checked ? map : null));
    lySupply.addEventListener("change", () => setMarkersVisible(supplyMarkers, lySupply.checked));
    lyPlanned.addEventListener("change", () => setMarkersVisible(plannedMarkers, lyPlanned.checked));
    lyLSOA.addEventListener("change", () => lsoaLayer.setMap(lyLSOA.checked ? map : null));
  }

  function initSortUI() {
    const sortEta = document.getElementById("sortEta");
    const sortDist= document.getElementById("sortDist");

    function setActive(mode) {
      sortMode = mode;
      sortEta.classList.toggle("active", mode==="eta");
      sortDist.classList.toggle("active", mode==="dist");

      if (lastResults.length) renderList(sortResults(lastResults));
    }

    sortEta.addEventListener("click", () => setActive("eta"));
    sortDist.addEventListener("click", () => setActive("dist"));
  }

  function sortResults(arr) {
    const copy = [...arr];
    if (sortMode === "dist") copy.sort((a,b) => a.distanceMeters - b.distanceMeters);
    else copy.sort((a,b) => a.durationTrafficSec - b.durationTrafficSec);
    return copy;
  }

  function fmtKm(m) {
    return (m/1000).toFixed(1) + " km";
  }
  function fmtMin(s) {
    return Math.max(1, Math.round(s/60)) + " min";
  }

  function renderList(results) {
    const list = document.getElementById("list");
    list.innerHTML = "";

    const top = results.slice(0, TOP_N);
    setCount(top.length);

    if (!top.length) {
      list.innerHTML = `
        <div class="item" style="cursor:default;">
          <div class="name">No results.</div>
          <div class="meta">Try a different origin or ensure chargers layer is loaded.</div>
        </div>`;
      return;
    }

    for (let i=0; i<top.length; i++) {
      const r = top[i];
      const delay = Math.max(0, r.durationTrafficSec - r.durationSec);
      const badgeClass = delay <= 60 ? "good" : "warn";
      const badgeText  = delay <= 60 ? "low delay" : `+${fmtMin(delay)}`;

      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        <div class="top">
          <div class="name">#${i+1} ${escapeHtml(r.name)}</div>
          <span class="badge ${badgeClass}">${badgeText}</span>
        </div>
        <div class="meta">
          ETA (traffic): <b>${fmtMin(r.durationTrafficSec)}</b>
          &nbsp;•&nbsp; Distance: <b>${fmtKm(r.distanceMeters)}</b><br/>
          Normal time: ${fmtMin(r.durationSec)}
        </div>
      `;

      div.addEventListener("click", () => {
        highlightMarker(r.id);
        previewRoute(originLatLng, r.destLatLng);
      });

      list.appendChild(div);
    }
  }

  function previewRoute(origin, dest) {
    if (!origin || !dest) return;

    directionsService.route({
      origin,
      destination: dest,
      travelMode: google.maps.TravelMode.DRIVING,
      drivingOptions: {
        departureTime: new Date(),
        trafficModel: google.maps.TrafficModel.BEST_GUESS
      }
    }, (result, status) => {
      if (status !== "OK" || !result) {
        setStatus("Route preview failed: " + status);
        return;
      }
      directionsRenderer.setDirections(result);
      const leg = result.routes[0].legs[0];
      const durTraffic = leg.duration_in_traffic ? leg.duration_in_traffic.text : "(n/a)";
      setStatus(`ETA (traffic): ${durTraffic} | Distance: ${leg.distance.text}\nTip: Driver view is locked to Cardiff.`);
    });
  }

  function haversineMeters(a, b) {
    const R = 6371000;
    const toRad = (x) => x * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLng = toRad(b.lng - a.lng);
    const s1 = Math.sin(dLat/2), s2 = Math.sin(dLng/2);
    const aa = s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
    return 2*R*Math.asin(Math.min(1, Math.sqrt(aa)));
  }

  function chunk(arr, size) {
    const out = [];
    for (let i=0; i<arr.length; i+=size) out.push(arr.slice(i, i+size));
    return out;
  }

  function distanceMatrixPromise(origin, destinations) {
    return new Promise((resolve, reject) => {
      distanceMatrixService.getDistanceMatrix({
        origins: [origin],
        destinations,
        travelMode: google.maps.TravelMode.DRIVING,
        drivingOptions: { departureTime: new Date(), trafficModel: google.maps.TrafficModel.BEST_GUESS },
        unitSystem: google.maps.UnitSystem.METRIC
      }, (res, status) => {
        if (status !== "OK" || !res) reject(new Error("DistanceMatrix failed: " + status));
        else resolve(res);
      });
    });
  }

  async function recommendBestChargers() {
    if (!originLatLng) {
      setStatus("Please set origin first (search or my location).");
      return;
    }
    setStatus("Computing best chargers with live traffic…");

    // pre-filter nearest by straight-line distance
    const origin = { lat: originLatLng.lat(), lng: originLatLng.lng() };
    const candidates = [];

    for (let i=0; i<supplyMarkers.length; i++) {
      const m = supplyMarkers[i];
      const pos = m.getPosition();
      if (!pos) continue;

      const d = haversineMeters(origin, { lat: pos.lat(), lng: pos.lng() });
      candidates.push({
        id: m.__id,
        name: m.getTitle() || "Existing charger",
        destLatLng: pos,
        marker: m,
        straightDist: d
      });
    }

    candidates.sort((a,b) => a.straightDist - b.straightDist);
    const shortlist = candidates.slice(0, MAX_STRAIGHTLINE_CANDIDATES);

    // Distance Matrix has size limits (25 destinations per request)
    const destChunks = chunk(shortlist.map(x => x.destLatLng), 25);

    const results = [];
    let processed = 0;

    for (let ci=0; ci<destChunks.length; ci++) {
      const dm = await distanceMatrixPromise(originLatLng, destChunks[ci]);
      const row = (dm.rows && dm.rows[0] && dm.rows[0].elements) ? dm.rows[0].elements : [];
      for (let j=0; j<row.length; j++) {
        const el = row[j];
        const item = shortlist[processed + j];
        if (!item) continue;

        if (el.status !== "OK") continue;

        const distM = el.distance?.value ?? null;
        const durS  = el.duration?.value ?? null;
        // In JS Distance Matrix, traffic time can be provided as duration_in_traffic in some cases
        const durTS = el.duration_in_traffic?.value ?? durS;

        if (distM == null || durS == null || durTS == null) continue;

        results.push({
          id: item.id,
          name: item.name,
          destLatLng: item.destLatLng,
          distanceMeters: distM,
          durationSec: durS,
          durationTrafficSec: durTS
        });
      }
      processed += row.length;
      setStatus(`Computing… ${Math.min(processed, shortlist.length)}/${shortlist.length} checked`);
    }

    lastResults = sortResults(results);
    renderList(lastResults);

    if (lastResults.length) {
      setStatus("Done. Click a list item to highlight and preview route.");
    } else {
      setStatus("No results returned. Check API enablement/quota.");
    }
  }

  function initSearch() {
    const input = document.getElementById("q");
    const btnSearch = document.getElementById("btnSearch");

    // Prefer Places Autocomplete if available
    if (google.maps.places && google.maps.places.Autocomplete) {
      const bounds = new google.maps.LatLngBounds(
        new google.maps.LatLng(CARDIFF_BOUNDS.south, CARDIFF_BOUNDS.west),
        new google.maps.LatLng(CARDIFF_BOUNDS.north, CARDIFF_BOUNDS.east)
      );

      const ac = new google.maps.places.Autocomplete(input, {
        bounds,
        strictBounds: true,
        componentRestrictions: { country: "gb" },
        fields: ["geometry", "formatted_address", "name"]
      });

      ac.addListener("place_changed", () => {
        const place = ac.getPlace();
        if (!place || !place.geometry || !place.geometry.location) {
          setStatus("Search failed. Try another query.");
          return;
        }
        const loc = place.geometry.location;
        if (!withinCardiff(loc)) {
          setStatus("Result is outside Cardiff bounds. Try a Cardiff address/place.");
          return;
        }
        setOrigin(loc, place.name || place.formatted_address || "Origin");
      });

      btnSearch.addEventListener("click", () => {
        // If user types and clicks search, trigger a geocode fallback
        if (input.value.trim().length < 2) return;
        geocodeQuery(input.value.trim());
      });

    } else {
      // Fallback: plain geocoding
      btnSearch.addEventListener("click", () => {
        if (input.value.trim().length < 2) return;
        geocodeQuery(input.value.trim());
      });
    }
  }

  function geocodeQuery(q) {
    const bounds = new google.maps.LatLngBounds(
      new google.maps.LatLng(CARDIFF_BOUNDS.south, CARDIFF_BOUNDS.west),
      new google.maps.LatLng(CARDIFF_BOUNDS.north, CARDIFF_BOUNDS.east)
    );

    geocoder.geocode({
      address: q,
      bounds,
      componentRestrictions: { country: "GB" }
    }, (results, status) => {
      if (status !== "OK" || !results || !results.length) {
        setStatus("Search failed. Try another query.");
        return;
      }
      const loc = results[0].geometry.location;
      if (!withinCardiff(loc)) {
        setStatus("Result is outside Cardiff bounds. Try a Cardiff address/place.");
        return;
      }
      setOrigin(loc, results[0].formatted_address || "Origin");
    });
  }

  function escapeHtml(s) {
    return String(s || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  async function initMap() {
    map = new google.maps.Map(document.getElementById("map"), {
      center: CARDIFF_CENTER,
      zoom: 12,
      mapTypeControl: false,
      streetViewControl: false,
      fullscreenControl: true,
      restriction: {
        latLngBounds: CARDIFF_BOUNDS,
        strictBounds: true
      }
    });

    info = new google.maps.InfoWindow();

    trafficLayer = new google.maps.TrafficLayer();
    trafficLayer.setMap(map);

    // Optional LSOA boundary layer (OFF by default)
    lsoaLayer = new google.maps.Data();
    lsoaLayer.setStyle({
      fillColor: "#93c5fd",
      fillOpacity: 0.18,
      strokeColor: "#2563eb",
      strokeOpacity: 0.8,
      strokeWeight: 1
    });
    lsoaLayer.setMap(null);

    lsoaLayer.addListener("click", (e) => {
      const cd = e.feature.getProperty("LSOA21CD") || e.feature.getProperty("lsoa21cd") || "";
      const nm = e.feature.getProperty("LSOA21NM") || e.feature.getProperty("lsoa21nm") || "";
      info.setContent(`<b>LSOA</b><br/>${escapeHtml(cd)}<br/>${escapeHtml(nm)}`);
      info.setPosition(e.latLng);
      info.open(map);
    });

    directionsService  = new google.maps.DirectionsService();
    directionsRenderer = new google.maps.DirectionsRenderer({ map, suppressMarkers: true });

    distanceMatrixService = new google.maps.DistanceMatrixService();
    geocoder = new google.maps.Geocoder();

    initLayersUI();
    initSortUI();
    initSearch();

    // Buttons
    document.getElementById("btnMyLoc").addEventListener("click", () => {
      setStatus("Getting your location…");
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const loc = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
          // allow outside Cardiff if user is outside, but if so: clamp to Cardiff? better prompt
          if (!withinCardiff(loc)) {
            setStatus("Your location is outside Cardiff bounds. For demo, please search an address within Cardiff.");
            return;
          }
          setOrigin(loc, "My location");
        },
        (err) => setStatus("Geolocation denied/unavailable."),
        { enableHighAccuracy: true, timeout: 8000 }
      );
    });

    document.getElementById("btnRecommend").addEventListener("click", recommendBestChargers);

    // Load data
    try {
      setStatus("Loading charger data…");

      const [lsoa, supply, planned] = await Promise.all([
        loadGeoJSON(DATA_URLS.lsoa),
        loadGeoJSON(DATA_URLS.supply),
        loadGeoJSON(DATA_URLS.planned)
      ]);

      // LSOA
      lsoaLayer.addGeoJson(lsoa);

      // Markers
      supplyMarkers  = addSupplyMarkers(supply);
      plannedMarkers = addPlannedMarkers(planned);

      setStatus(`Loaded.\nExisting chargers: ${supplyMarkers.length}\nPlanned sites: ${plannedMarkers.length}\n\nSet origin → Recommend.`);
    } catch (err) {
      console.error(err);
      setStatus("FAILED to load data. Check console & file paths.\n" + String(err));
      alert(String(err));
    }
  }

  window.initMap = initMap;

  // Load Google Maps JS (include Places for search autocomplete)
  (function loadGoogleMaps() {
    const s = document.createElement("script");
    s.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(GMAPS_KEY)}&callback=initMap&v=weekly&libraries=places`;
    s.async = true;
    s.defer = true;
    document.head.appendChild(s);
  })();
</script>
</body>
</html>
