<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cardiff EV Charging â€“ Planner View (v5: Cascading Experiment)</title>
  <style>
    html, body { height:100%; margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #map { height:100%; width:100%; }
    #map img { max-width:none !important; }

    .panel{
      position:absolute; top:12px; left:12px; z-index:5;
      background:rgba(255,255,255,0.97);
      border:1px solid #ddd; border-radius:14px;
      padding:14px; width:540px;
      box-shadow:0 4px 18px rgba(0,0,0,0.12);
      max-height: calc(100vh - 24px);
      overflow:auto;
    }
    .title{ font-weight:900; font-size:20px; margin:0 0 6px; }
    .row{ display:flex; align-items:center; gap:10px; margin:8px 0; flex-wrap:wrap; }
    .small{ color:#374151; font-size:12px; }
    .muted{ color:#6b7280; font-size:12px; }
    .btn{
      background:#111827; color:#fff; border:none; border-radius:10px;
      padding:10px 14px; cursor:pointer; font-size:13px; font-weight:900;
    }
    .btn.secondary{ background:#6b7280; }
    .btn.green{ background:#059669; }
    .btn:disabled{ opacity:0.4; cursor:not-allowed; }
    .btn:not(:disabled):hover{ opacity:0.85; }

    .input, select{
      border:1px solid #e5e7eb; border-radius:10px;
      padding:10px 12px; outline:none; font-size:13px; background:#fff;
    }

    .kpis{ display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:8px; }
    .kpis.three{ grid-template-columns:1fr 1fr 1fr; }
    .card{ border:1px solid #eee; border-radius:12px; padding:10px 12px; background:#fff; position:relative; }
    .card .h{ font-size:11px; color:#6b7280; margin-bottom:4px; }
    .card .v{ font-size:16px; font-weight:900; color:#111827; }
    .card.winner{ border-color:#059669; background:#ecfdf5; }
    .card.winner::after{
      content:"â˜…"; position:absolute; top:6px; right:8px;
      font-size:14px; color:#059669;
    }

    .section{ margin-top:10px; padding-top:10px; border-top:1px solid #eee; }
    .pill{
      display:inline-flex; align-items:center;
      border:1px solid #e5e7eb; border-radius:999px;
      padding:6px 10px; font-size:12px; background:#fff;
      cursor:pointer; user-select:none;
    }
    .pill.active{ background:#111827; color:#fff; border-color:#111827; }

    .list{ margin-top:8px; max-height:200px; overflow:auto; border:1px solid #eee; border-radius:12px; background:#fff; }
    .item{ padding:10px 12px; border-bottom:1px solid #f1f5f9; cursor:pointer; }
    .item:hover{ background:#f8fafc; }
    .item:last-child{ border-bottom:none; }
    .itemTitle{ font-weight:900; font-size:13px; margin-bottom:4px; }
    .itemMeta{ font-size:12px; color:#374151; display:flex; gap:8px; flex-wrap:wrap; }
    .badge{
      display:inline-flex; align-items:center;
      padding:2px 8px; border-radius:999px;
      border:1px solid #e5e7eb; font-size:11px; color:#111827;
      background:#fff;
    }

    .status{ margin-top:8px; font-size:12px; color:#111827; white-space:pre-wrap; }
    .legend{ margin-top:10px; font-size:12px; line-height:1.35; }
    .swatch{ display:inline-block; width:12px; height:12px; border-radius:999px; margin-right:8px; border:2px solid rgba(255,255,255,0.9); box-shadow:0 0 0 1px rgba(0,0,0,0.12); }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:11px; }
    details summary{ cursor:pointer; font-weight:800; }

    .stageBox{
      border:1px solid #e5e7eb; border-radius:12px; padding:12px;
      margin-top:8px; background:#fafbfc;
    }
    .stageBox.active{ border-color:#2563eb; background:#eff6ff; }
    .stageBox.done{ border-color:#059669; background:#ecfdf5; }
    .stageLabel{
      font-weight:900; font-size:14px; margin-bottom:8px;
      display:flex; align-items:center; gap:8px;
    }
    .stageNum{
      display:inline-flex; align-items:center; justify-content:center;
      width:24px; height:24px; border-radius:999px;
      background:#e5e7eb; color:#374151;
      font-size:12px; font-weight:900;
    }
    .stageNum.active{ background:#2563eb; color:#fff; }
    .stageNum.done{ background:#059669; color:#fff; }
    .winnerTag{
      display:inline-flex; align-items:center; gap:4px;
      padding:3px 10px; border-radius:999px;
      background:#059669; color:#fff; font-size:11px; font-weight:900;
    }
    .stageResult{ margin-top:8px; font-size:12px; }

    .tbl{ width:100%; border-collapse:collapse; margin-top:6px; font-size:12px; }
    .tbl th, .tbl td{ padding:6px 8px; text-align:left; border-bottom:1px solid #eee; }
    .tbl th{ color:#6b7280; font-weight:700; background:#f9fafb; }
    .tbl td.win{ background:#ecfdf5; font-weight:900; color:#059669; }

    /* Editing toolbar */
    .editBar{
      display:flex; align-items:center; gap:6px; flex-wrap:wrap;
      padding:10px 12px; border:2px solid #e5e7eb; border-radius:12px;
      background:#fafbfc; margin-top:8px;
    }
    .editBar.active-add{ border-color:#10b981; background:#ecfdf5; }
    .editBar.active-exclude{ border-color:#ef4444; background:#fef2f2; }
    .editBar.active-lock{ border-color:#f59e0b; background:#fffbeb; }

    .modeBtn{
      padding:6px 10px; border-radius:8px; border:1.5px solid #d1d5db;
      background:#fff; font-size:12px; font-weight:700; cursor:pointer;
      display:inline-flex; align-items:center; gap:4px;
    }
    .modeBtn:hover{ background:#f3f4f6; }
    .modeBtn.sel-navigate{ border-color:#2563eb; background:#eff6ff; color:#2563eb; }
    .modeBtn.sel-add{ border-color:#10b981; background:#ecfdf5; color:#059669; }
    .modeBtn.sel-exclude{ border-color:#ef4444; background:#fef2f2; color:#dc2626; }
    .modeBtn.sel-lock{ border-color:#f59e0b; background:#fffbeb; color:#d97706; }

    .editCount{
      display:inline-flex; align-items:center; gap:4px;
      padding:3px 8px; border-radius:999px;
      font-size:11px; font-weight:700; border:1px solid #e5e7eb; background:#fff;
    }
    .editCount.excluded{ border-color:#fca5a5; color:#dc2626; }
    .editCount.locked{ border-color:#fcd34d; color:#d97706; }
    .editCount.custom{ border-color:#6ee7b7; color:#059669; }

    /* Map cursor modes */
    .cursor-add #map { cursor: crosshair !important; }
    .cursor-exclude #map { cursor: not-allowed !important; }
    .cursor-lock #map { cursor: cell !important; }

    .editLog{ max-height:120px; overflow:auto; margin-top:6px; font-size:11px; color:#6b7280; border:1px solid #eee; border-radius:8px; padding:6px 8px; background:#fff; }
    .editLog div{ padding:2px 0; border-bottom:1px solid #f9fafb; }
    .editLog div:last-child{ border-bottom:none; }
  </style>
</head>

<body>
<div id="map"></div>

<div class="panel">
  <div class="title">Planner (Cardiff) â€“ v5 Cascading Experiment</div>
  <div class="muted">
    3-stage cascading: <b>â‘ </b> LSOA modes â†’ <b>â‘¡</b> GA modes â†’ <b>â‘¢</b> Hybrid (best LSOA seed â†’ best GA).
    Equity is evaluated after optimisation (not in scoring).
  </div>

  <!-- Global settings -->
  <div class="section">
    <div style="font-weight:900; margin-bottom:6px;">Global settings</div>
    <div class="row">
      <label class="small">Target year</label>
      <select id="yearSel">
        <option value="2026">2026</option>
        <option value="2030" selected>2030</option>
        <option value="2035">2035</option>
      </select>
      <label class="small">Add P</label>
      <input id="pSel" class="input" style="width:80px" type="number" min="1" value="10"/>
    </div>

    <div class="row">
      <label class="small"><input id="ckSupply" type="checkbox" checked> Existing chargers</label>
      <label class="small"><input id="ckLSOA" type="checkbox" checked> LSOA boundary</label>
      <label class="small"><input id="ckCandidates" type="checkbox" checked> Candidates</label>
    </div>

    <div class="row">
      <span class="pill active" id="tabStages">Stages</span>
      <span class="pill" id="tabGap">Gap map</span>
      <span class="pill" id="tabCompare">Final compare</span>
    </div>

    <div class="row">
      <label class="small"><input id="ckLSOAPlan" type="checkbox" checked> Show LSOA plan</label>
      <label class="small"><input id="ckGAPlan" type="checkbox" checked> Show GA/Hybrid plan</label>
    </div>

    <div class="row">
      <button id="btnRunAll" class="btn green" style="font-size:14px;">â–¶ Run All 3 Stages</button>
      <button id="btnExportFinal" class="btn secondary" disabled>Export final (CSV)</button>
      <button id="btnExportFinalGeo" class="btn secondary" disabled>Export final (GeoJSON)</button>
    </div>

    <!-- Scenario editing toolbar -->
    <div class="editBar" id="editBar">
      <span style="font-weight:900; font-size:12px;">Scenario editing</span>
      <button class="modeBtn sel-navigate" id="modeNavigate" onclick="setEditMode('navigate')">ðŸ–± Navigate</button>
      <button class="modeBtn" id="modeAdd" onclick="setEditMode('add')">ï¼‹ Add site</button>
      <button class="modeBtn" id="modeExclude" onclick="setEditMode('exclude')">âœ• Exclude</button>
      <button class="modeBtn" id="modeLock" onclick="setEditMode('lock')">ðŸ”’ Lock</button>
      <button class="modeBtn" id="btnResetEdits" onclick="resetEdits()" style="margin-left:auto;">â†º Reset all</button>
    </div>
    <div class="row" style="margin-top:4px;">
      <span class="editCount custom" id="countCustom">+0 added</span>
      <span class="editCount excluded" id="countExcluded">0 excluded</span>
      <span class="editCount locked" id="countLocked">0 locked</span>
      <span class="muted" id="editModeHint">Navigate mode â€” click map to view info.</span>
    </div>
    <div class="editLog" id="editLog" style="display:none;"></div>

    <details style="margin-top:8px;">
      <summary class="small">Advanced options</summary>

      <div class="row" style="margin-top:10px;">
        <div class="badge" style="font-weight:900;">Coverage</div>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Coverage metric</label>
        <select id="covMode">
          <option value="distance">Distance (km radius)</option>
          <option value="time" selected>Travel-time approx (min)</option>
        </select>
      </div>
      <div class="row" id="rowSvcKm">
        <label class="small" style="min-width:150px;">Service radius D (km)</label>
        <input id="svcKm" class="input" style="width:80px" type="number" min="0.2" step="0.1" value="1.5"/>
      </div>
      <div class="row" id="rowTimeMin">
        <label class="small" style="min-width:150px;">Time threshold T (min)</label>
        <input id="svcMin" class="input" style="width:80px" type="number" min="2" step="1" value="6"/>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Detour factor</label>
        <input id="detourK" class="input" style="width:80px" type="number" min="1.0" max="2.5" step="0.05" value="1.25"/>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Speed (km/h)</label>
        <input id="speedKmh" class="input" style="width:80px" type="number" min="10" max="80" step="1" value="28"/>
      </div>

      <div class="row" style="margin-top:8px;">
        <div class="badge" style="font-weight:900;">Spacing</div>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Min spacing (m)</label>
        <input id="minSpacing" class="input" style="width:80px" type="number" min="0" step="50" value="700"/>
        <label class="small"><input id="ckSpread" type="checkbox" checked> enforce</label>
      </div>

      <div class="row" style="margin-top:8px;">
        <div class="badge" style="font-weight:900;">Weights (no equity in score)</div>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Demand wD</label>
        <input id="wDemand" type="range" min="0" max="1" step="0.01" value="0.65" style="flex:1;">
        <span class="badge" id="wDemandVal">0.65</span>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Gap wG</label>
        <input id="wGap" type="range" min="0" max="1" step="0.01" value="0.35" style="flex:1;">
        <span class="badge" id="wGapVal">0.35</span>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Constraint wP</label>
        <input id="wPenalty" type="range" min="0" max="1" step="0.01" value="0.25" style="flex:1;">
        <span class="badge" id="wPenaltyVal">0.25</span>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">NearExisting wN</label>
        <input id="wNear" type="range" min="0" max="1" step="0.01" value="0.20" style="flex:1;">
        <span class="badge" id="wNearVal">0.20</span>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Cluster wC</label>
        <input id="wCluster" type="range" min="0" max="1" step="0.01" value="0.25" style="flex:1;">
        <span class="badge" id="wClusterVal">0.25</span>
      </div>

      <div class="row" style="margin-top:8px;">
        <div class="badge" style="font-weight:900;">Worst-served</div>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Worst-served group (%)</label>
        <input id="worstPct" class="input" style="width:80px" type="number" min="1" max="50" step="1" value="20"/>
      </div>

      <div class="row" style="margin-top:8px;">
        <div class="badge" style="font-weight:900;">Equity evaluation</div>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Equity direction</label>
        <select id="equityDir">
          <option value="highNeedHigh" selected>Higher = higher need</option>
          <option value="highNeedLow">Lower = higher need</option>
        </select>
      </div>

      <div class="row" style="margin-top:8px;">
        <div class="badge" style="font-weight:900;">GA tuning</div>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Repeat runs N</label>
        <input id="gaRuns" class="input" style="width:80px" type="number" min="1" max="20" step="1" value="5"/>
        <span class="muted">Each GA mode runs N times; report median Â± Ïƒ</span>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Population</label>
        <input id="gaPop" class="input" style="width:80px" type="number" min="10" step="10" value="120"/>
        <label class="small" style="min-width:100px;">Generations</label>
        <input id="gaGen" class="input" style="width:80px" type="number" min="10" step="10" value="240"/>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Mutation rate</label>
        <input id="gaMut" class="input" style="width:80px" type="number" min="0" max="1" step="0.01" value="0.45"/>
        <label class="small" style="min-width:100px;">Elite rate</label>
        <input id="gaElite" class="input" style="width:80px" type="number" min="0" max="0.5" step="0.01" value="0.08"/>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Seed with LSOA (%)</label>
        <input id="gaSeedPct" class="input" style="width:80px" type="number" min="0" max="0.8" step="0.05" value="0.15"/>
      </div>

      <div class="row" style="margin-top:8px;">
        <div class="badge" style="font-weight:900;">Performance</div>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Coverage sample</label>
        <input id="covSampleN" class="input" style="width:80px" type="number" min="200" step="100" value="900"/>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">GA eval sample</label>
        <input id="gaEvalSample" class="input" style="width:80px" type="number" min="10" step="10" value="80"/>
      </div>
      <div class="row">
        <label class="small" style="min-width:150px;">Max P (guard)</label>
        <input id="maxP" class="input" style="width:80px" type="number" min="10" step="10" value="150"/>
      </div>
    </details>
  </div>

  <!-- Needs dashboard -->
  <div class="section">
    <div style="font-weight:900; margin-bottom:6px;">Needs & gap</div>
    <div class="kpis">
      <div class="card"><div class="h">Current supply</div><div class="v" id="k_supply">â€“</div></div>
      <div class="card"><div class="h">Target (year)</div><div class="v" id="k_target">â€“</div></div>
      <div class="card"><div class="h">Gap</div><div class="v" id="k_gap">â€“</div></div>
      <div class="card"><div class="h">Candidates</div><div class="v" id="k_candidates">â€“</div></div>
    </div>
    <div class="status" id="status">Click "Run All 3 Stages" to begin the cascading experiment.</div>
  </div>

  <!-- ====== STAGES PANEL ====== -->
  <div id="stagesPanel">

    <!-- STAGE 1: LSOA -->
    <div class="section">
      <div class="stageBox" id="stage1Box">
        <div class="stageLabel">
          <span class="stageNum" id="stage1Num">1</span>
          Stage 1 â€” LSOA Baseline (Rank vs Greedy)
          <span id="stage1Winner" style="display:none;"></span>
        </div>
        <div class="muted">Compare two LSOA selection modes. Best mode is used as seed in Stage 3.</div>

        <div class="row">
          <button id="btnStage1" class="btn">Run Stage 1</button>
          <span class="muted" id="stage1Time"></span>
        </div>

        <div id="stage1Results" style="display:none;">
          <table class="tbl">
            <thead>
              <tr><th>KPI</th><th>Rank</th><th>Greedy+Spacing</th></tr>
            </thead>
            <tbody id="stage1Body"></tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- STAGE 2: GA -->
    <div class="section">
      <div class="stageBox" id="stage2Box">
        <div class="stageLabel">
          <span class="stageNum" id="stage2Num">2</span>
          Stage 2 â€” GA Alone (3 modes)
          <span id="stage2Winner" style="display:none;"></span>
        </div>
        <div class="muted">Compare Score-only vs Coverageâ†’Score vs Lexicographic. Random init (no LSOA seed). Each mode runs N times; median KPIs used for comparison.</div>

        <div class="row">
          <button id="btnStage2" class="btn" disabled>Run Stage 2</button>
          <span class="muted" id="stage2Time"></span>
        </div>

        <div id="stage2Results" style="display:none;">
          <div class="muted" id="stage2RunInfo" style="margin-bottom:6px;"></div>
          <table class="tbl">
            <thead>
              <tr><th>KPI (median Â± Ïƒ)</th><th>Score</th><th>Covâ†’Score</th><th>Lex</th></tr>
            </thead>
            <tbody id="stage2Body"></tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- STAGE 3: Hybrid -->
    <div class="section">
      <div class="stageBox" id="stage3Box">
        <div class="stageLabel">
          <span class="stageNum" id="stage3Num">3</span>
          Stage 3 â€” Hybrid (Best LSOA â†’ Best GA)
          <span id="stage3Winner" style="display:none;"></span>
        </div>
        <div class="muted" id="stage3Desc">
          Uses the best LSOA mode as seed, refined by the best GA mode. Hybrid also runs N times.
        </div>

        <div class="row">
          <button id="btnStage3" class="btn" disabled>Run Stage 3</button>
          <span class="muted" id="stage3Time"></span>
        </div>

        <div id="stage3Results" style="display:none;">
          <div class="muted" id="stage3RunInfo" style="margin-bottom:6px;"></div>
          <table class="tbl">
            <thead>
              <tr><th>KPI (median Â± Ïƒ)</th><th id="stage3ColA">Best LSOA</th><th id="stage3ColB">Best GA (alone)</th><th>Hybrid (final)</th></tr>
            </thead>
            <tbody id="stage3Body"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- ====== FINAL COMPARE PANEL ====== -->
  <div id="comparePanel" style="display:none;">
    <div class="section">
      <div style="font-weight:900; margin-bottom:6px;">Final comparison (all methods â€” GA/Hybrid show median of N runs)</div>
      <table class="tbl">
        <thead>
          <tr><th>KPI</th><th>LSOA Rank</th><th>LSOA Greedy</th><th>GA Score</th><th>GA Covâ†’Score</th><th>GA Lex</th><th>Hybrid</th></tr>
        </thead>
        <tbody id="finalBody"></tbody>
      </table>
    </div>

    <div class="section">
      <div style="font-weight:900; margin-bottom:6px;">Hybrid shortlist</div>
      <div class="list" id="hybridList"></div>
    </div>
  </div>

  <div class="legend">
    <b>Legend</b><br/>
    <div><span class="swatch" style="background:#2563eb;"></span>Blue: existing chargers</div>
    <div><span class="swatch" style="background:#f59e0b;"></span>Orange: candidates</div>
    <div><span class="swatch" style="background:#10b981;"></span>Green: custom added sites</div>
    <div><span class="swatch" style="background:#d1d5db;"></span>Grey: excluded candidates</div>
    <div><span class="swatch" style="background:#f59e0b; border:2px solid #d97706;"></span>Gold (larger): locked candidates</div>
    <div><span class="swatch" style="background:#ef4444;"></span>Red star: LSOA plan (best mode)</div>
    <div><span class="swatch" style="background:#7c3aed;"></span>Purple diamond: GA/Hybrid plan (final)</div>
    <div class="muted" style="margin-top:6px;">Gap map colors LSOA by high demand + low provision.</div>
  </div>
</div>

<script>
  // ===============================
  // 0) CONFIG
  // ===============================
  const GMAPS_KEY = "AIzaSyAUproFl8jRStUlFwOKbQ8yh2CjNJ_H2c4";

  const BASE = new URL("./", window.location.href);
  const DATA_URLS = {
    supply:     new URL("data/processed/supply_chargers_ocm.geojson", BASE).href,
    lsoa:       new URL("data/processed/demand_lsoa_cardiff_exact_pop_wgs84_enriched.geojson", BASE).href,
    candidates: new URL("data/processed/demand_points_cardiff_exact_pop_wgs84.geojson", BASE).href
  };

  const CARDIFF_BOUNDS = { north: 51.566, south: 51.410, east: -3.065, west: -3.333 };
  const TARGET_BY_YEAR = { "2026": 700, "2030": 1500, "2035": 2000 };

  // Fast distance
  const R_EARTH = 6371000;
  const R2 = R_EARTH * R_EARTH;
  const DEG2RAD = Math.PI / 180;

  const FIELD = {
    code:   ["LSOA21CD","lsoa21cd","LSOA11CD","lsoa11cd","code","id"],
    pop:    ["population","pop","pop_total","Pop","total_pop","Total"],
    demand: ["demand","demand_score","ev_owners","owners","weight"],
    equity_proxy: ["equity_proxy","equity_wimd","equity_norm"],
    wimd_norm:    ["wimd_norm","imd_norm","wimd2019_norm"],
    wimd_rank:    ["wimd_rank","imd_rank","wimd2019_rank"],
    wimd_decile:  ["wimd_decile","imd_decile","wimd2019_decile"],
    median_age:   ["median_age","median age","Median age mid-2024","Median age mid-2023","Median age mid-2022"],
    parking_constraint: ["parking_constraint","constraint","install_constraint"],
    share_flats:  ["share_flats","pct_flats","flats_share"],
    share_dense:  ["share_dense","pct_dense","dense_share","share_terraced","pct_terraced"],
    share_rented: ["share_rented","pct_rented","rented_share"],
    share_no_car: ["share_no_car","pct_no_car","no_car_share"],
    sockets:["sockets","SocketCount","socket_count","connectors","num_sockets","units"],
    name:   ["name","operator","location","Site","address","Address"]
  };

  // ===============================
  // 1) STATE
  // ===============================
  let map, info;
  let supplyLayer, lsoaLayer, candLayer, lsoaPlanLayer, gaPlanLayer;

  let lsoaIndex = [];
  let lsoaByCodeMap = new Map();
  let supplyPts = [];
  let candPts = [];       // all candidates (original + custom)
  let candPtsOriginal = []; // snapshot of loaded candidates (for reset)

  let activeTab = "stages";

  // Editing state
  let editMode = "navigate";  // "navigate" | "add" | "exclude" | "lock"
  let excludedSet = new Set(); // candidate objects to exclude from optimization
  let lockedSet = new Set();   // candidate objects to force-include in every solution
  let customCount = 0;         // counter for naming custom candidates
  let editLogEntries = [];     // edit history

  // Results store for all 6 methods
  let results = {
    lsoaRank: null,
    lsoaGreedy: null,
    gaScore: null,
    gaCovScore: null,
    gaLex: null,
    hybrid: null
  };
  let metrics = {};  // same keys â†’ computed metrics
  let bestLSOAMode = null;  // "rank" or "greedy"
  let bestGAMode = null;    // "score", "covScore", or "lex"
  let finalPlanLSOA = null; // solution displayed on map (LSOA layer)
  let finalPlanGA = null;   // solution displayed on map (GA/Hybrid layer)

  let worstCache = { set: new Set(), codes: [], currentAgg: new Map(), pct: 20 };

  // ===============================
  // 2) UTILS
  // ===============================
  function setStatus(msg){ document.getElementById("status").textContent = msg || ""; }
  function escapeHtml(s){
    return String(s||"").replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }
  function num(x, fb=0){ const v=Number(x); return Number.isFinite(v)? v: fb; }
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function pctTo01(x){
    const v = num(x, NaN);
    if(!Number.isFinite(v)) return NaN;
    return (v > 1.0001) ? clamp01(v/100) : clamp01(v);
  }
  function getProp(props, keys, fb=null){
    for(const k of keys){
      if(props && props[k] !== undefined && props[k] !== null && props[k] !== "") return props[k];
    }
    return fb;
  }
  async function loadGeoJSON(url){
    const res = await fetch(url,{cache:"no-store"});
    if(!res.ok) throw new Error("Fetch failed: " + res.status + " " + url);
    return await res.json();
  }
  function looksLike27700(lng, lat){ return Math.abs(lng) > 1000 || Math.abs(lat) > 1000; }

  function attachRad(p){
    p.latRad = p.lat * DEG2RAD;
    p.lngRad = p.lng * DEG2RAD;
    p.cosLat = Math.cos(p.latRad);
    return p;
  }
  function distSqFast(a, b){
    const dLat = b.latRad - a.latRad;
    const dLng = b.lngRad - a.lngRad;
    const cosAvg = (a.cosLat + b.cosLat) * 0.5;
    const x = dLng * cosAvg;
    return R2 * (x*x + dLat*dLat);
  }
  function distFast(a, b){ return Math.sqrt(distSqFast(a,b)); }

  function getDetourK(){ return Math.max(1.0, Math.min(2.5, num(document.getElementById("detourK").value, 1.25))); }
  function getSpeedKmh(){ return Math.max(10, Math.min(80, num(document.getElementById("speedKmh").value, 28))); }
  function getTimeThresholdMin(){ return Math.max(2, num(document.getElementById("svcMin").value, 6)); }
  function getCoverageMode(){ return String(document.getElementById("covMode").value || "time"); }
  function getServiceRadiusM(){
    const km = Math.max(0.2, num(document.getElementById("svcKm").value, 1.5));
    return km * 1000;
  }
  function getCoverageThresholdDistM(){
    const mode = getCoverageMode();
    if(mode === "distance") return getServiceRadiusM();
    const T = getTimeThresholdMin();
    const speed = getSpeedKmh();
    const k = getDetourK();
    return Math.max(50, ((T/60)*speed/k)*1000);
  }
  function updateCoverageUI(){
    const mode = getCoverageMode();
    document.getElementById("rowSvcKm").style.display = (mode==="time") ? "none" : "flex";
    document.getElementById("rowTimeMin").style.display = (mode==="time") ? "flex" : "none";
  }

  // icons
  function iconCircle(fill, scale, strokeW){
    return { path: google.maps.SymbolPath.CIRCLE, fillColor:fill, fillOpacity:1,
      strokeColor:"#ffffff", strokeOpacity:1, strokeWeight:strokeW, scale: scale };
  }
  function iconStar(fill, scale){
    return { path:"M 0,-10 L 2,-3 L 10,-3 L 4,1 L 6,9 L 0,4 L -6,9 L -4,1 L -10,-3 L -2,-3 Z",
      fillColor:fill, fillOpacity:0.95, strokeColor:"#ffffff", strokeOpacity:1, strokeWeight:1, scale:scale };
  }
  function iconDiamond(fill, scale){
    return { path:"M 0,-10 L 10,0 L 0,10 L -10,0 Z",
      fillColor:fill, fillOpacity:0.95, strokeColor:"#ffffff", strokeOpacity:1, strokeWeight:1, scale:scale };
  }

  // ===============================
  // 3) SCORING HELPERS
  // ===============================
  function computeEquityFromProps(props, fallbackMedianAge){
    const equityProxy = getProp(props, FIELD.equity_proxy, null);
    if(equityProxy !== null) return num(equityProxy, 0);
    const wimdNorm = getProp(props, FIELD.wimd_norm, null);
    if(wimdNorm !== null) return num(wimdNorm, 0);
    const r = num(getProp(props, FIELD.wimd_rank, NaN), NaN);
    if(Number.isFinite(r)) return -r;
    const d = num(getProp(props, FIELD.wimd_decile, NaN), NaN);
    if(Number.isFinite(d)) return (11 - d) / 10;
    return Number.isFinite(fallbackMedianAge) ? fallbackMedianAge : 0;
  }
  function computePenaltyFromProps(props){
    const pc = getProp(props, FIELD.parking_constraint, null);
    if(pc !== null){ const v = pctTo01(pc); if(Number.isFinite(v)) return v; }
    const flats=pctTo01(getProp(props,FIELD.share_flats,NaN)), dense=pctTo01(getProp(props,FIELD.share_dense,NaN)),
          rented=pctTo01(getProp(props,FIELD.share_rented,NaN)), nocar=pctTo01(getProp(props,FIELD.share_no_car,NaN));
    const arr=[flats,dense,rented,nocar].filter(Number.isFinite);
    if(!arr.length) return 0;
    return clamp01((Number.isFinite(flats)?0.40*flats:0)+(Number.isFinite(dense)?0.25*dense:0)+
      (Number.isFinite(rented)?0.25*rented:0)+(Number.isFinite(nocar)?0.10*nocar:0));
  }
  function getWeights(){
    let wd=num(document.getElementById("wDemand").value,0.65), wg=num(document.getElementById("wGap").value,0.35);
    const sumB=wd+wg; if(sumB>0){wd/=sumB; wg/=sumB;}else{wd=0.65;wg=0.35;}
    return { wd, wg, wp:num(document.getElementById("wPenalty").value,0.25),
      wn:num(document.getElementById("wNear").value,0.20), wc:num(document.getElementById("wCluster").value,0.25) };
  }
  function updateWeightUI(){
    const w=getWeights();
    document.getElementById("wDemandVal").textContent=w.wd.toFixed(2);
    document.getElementById("wGapVal").textContent=w.wg.toFixed(2);
    document.getElementById("wPenaltyVal").textContent=w.wp.toFixed(2);
    document.getElementById("wNearVal").textContent=w.wn.toFixed(2);
    document.getElementById("wClusterVal").textContent=w.wc.toFixed(2);
  }
  function normalize01(arr){
    let mn=Infinity, mx=-Infinity;
    for(const v of arr){ if(Number.isFinite(v)){mn=Math.min(mn,v);mx=Math.max(mx,v);} }
    if(!Number.isFinite(mn)||!Number.isFinite(mx)||mn===mx) return {norm:_=>0.5};
    return {norm:x=>(x-mn)/(mx-mn)};
  }

  // ===============================
  // 4) TABS & CHOROPLETH
  // ===============================
  function setTab(tab){
    activeTab = tab;
    document.getElementById("tabStages").classList.toggle("active", tab==="stages");
    document.getElementById("tabGap").classList.toggle("active", tab==="gap");
    document.getElementById("tabCompare").classList.toggle("active", tab==="compare");
    document.getElementById("stagesPanel").style.display = (tab==="stages") ? "block" : "none";
    document.getElementById("comparePanel").style.display = (tab==="compare") ? "block" : "none";
    styleLSOA();
  }
  function styleLSOA(){
    if(!lsoaLayer) return;
    if(activeTab === "gap"){
      lsoaLayer.setStyle(ft => {
        const s = num(ft.getProperty("_gapScore"), 0);
        let fill = "#10b981";
        if(s > 0.66) fill = "#f87171";
        else if(s > 0.33) fill = "#f59e0b";
        return { fillColor:fill, fillOpacity:0.42, strokeColor:"#111827", strokeOpacity:0.75, strokeWeight:2.5 };
      });
    } else {
      lsoaLayer.setStyle({ fillColor:"#93c5fd", fillOpacity:0.18, strokeColor:"#2563eb", strokeOpacity:0.85, strokeWeight:2.5 });
    }
  }

  // ===============================
  // 5) GEOMETRY & SPATIAL
  // ===============================
  function makePolygonsFromGeometry(geom){
    const polys=[];
    if(!geom) return polys;
    const toPath=ring=>ring.map(x=>({lat:x[1],lng:x[0]}));
    const buildPoly=rings=>new google.maps.Polygon({paths:rings.map(toPath)});
    if(geom.type==="Polygon") polys.push(buildPoly(geom.coordinates));
    else if(geom.type==="MultiPolygon"){ for(const p of geom.coordinates) polys.push(buildPoly(p)); }
    return polys;
  }
  function containsAny(polys, latLng){
    for(const p of polys){ if(google.maps.geometry.poly.containsLocation(latLng,p)) return true; }
    return false;
  }
  function joinPointToLSOA(latLng){
    for(const rec of lsoaIndex){ if(containsAny(rec.polygons,latLng)) return rec; }
    return null;
  }
  function computeSupplyTotal(){
    let sum=0; for(const p of supplyPts) sum+=num(p.sockets,0);
    if(sum===0 && supplyPts.length) sum=supplyPts.length;
    return sum;
  }
  function computeLSOAGapScores(){
    const supplyByLSOA=new Map();
    for(const s of supplyPts){
      const ll=new google.maps.LatLng(s.lat,s.lng);
      const rec=joinPointToLSOA(ll);
      if(!rec) continue;
      supplyByLSOA.set(rec.code,(supplyByLSOA.get(rec.code)||0)+num(s.sockets,1));
    }
    const dArr=[], sArr=[];
    for(const rec of lsoaIndex){ rec.supplyRaw=supplyByLSOA.get(rec.code)||0; dArr.push(num(rec.demandRaw,0)); sArr.push(num(rec.supplyRaw,0)); }
    const nd=normalize01(dArr), ns=normalize01(sArr);
    for(const rec of lsoaIndex){
      if(!rec.feature) continue;
      const d01=nd.norm(num(rec.demandRaw,0)), s01=ns.norm(num(rec.supplyRaw,0));
      const g=Math.max(0,Math.min(1,d01-0.7*s01));
      rec.gap01=g; rec.feature.setProperty("_gapScore",g);
    }
    for(const c of candPts){ const ll=new google.maps.LatLng(c.lat,c.lng); const rec=joinPointToLSOA(ll); c.gapRaw=rec?num(rec.gap01,0):0; }
  }

  // ===============================
  // 6) COVERAGE & METRICS
  // ===============================
  function getCoverageSampleN(){ return Math.max(200,Math.floor(num(document.getElementById("covSampleN").value,900))); }
  function sampleCandidatesForCoverage(){
    const N=candPts.length, want=Math.min(getCoverageSampleN(),N);
    if(want>=N) return candPts;
    const step=Math.max(1,Math.floor(N/want)); const out=[];
    for(let i=0;i<N&&out.length<want;i+=step) out.push(candPts[i]);
    while(out.length<want) out.push(candPts[out.length%N]);
    return out;
  }
  function computeDistancesToExisting(){
    if(!supplyPts.length){ for(const c of candPts){c.distToExistingM=NaN;c.distToExistingSq=Infinity;} return; }
    for(const c of candPts){
      let bestSq=Infinity;
      for(const s of supplyPts){ const dSq=distSqFast(c,s); if(dSq<bestSq) bestSq=dSq; }
      c.distToExistingSq=bestSq; c.distToExistingM=Number.isFinite(bestSq)?Math.sqrt(bestSq):NaN;
    }
  }
  function scoreCandidatesShared(){
    const dN=normalize01(candPts.map(c=>c.demandRaw)), eN=normalize01(candPts.map(c=>c.equityRaw)),
          gN=normalize01(candPts.map(c=>c.gapRaw)), constrN=normalize01(candPts.map(c=>c.penaltyRaw));
    const Rm=getCoverageThresholdDistM();
    const nearArr=candPts.map(c=>{const d=num(c.distToExistingM,NaN);return Number.isFinite(d)?clamp01(1-(d/Rm)):0;});
    const nearN=normalize01(nearArr);
    const w=getWeights();
    for(let i=0;i<candPts.length;i++){
      const c=candPts[i];
      c.d01=dN.norm(num(c.demandRaw,0)); c.e01=eN.norm(num(c.equityRaw,0));
      c.g01=gN.norm(num(c.gapRaw,0)); c.costConstr01=constrN.norm(num(c.penaltyRaw,0));
      c.costNear01=nearN.norm(nearArr[i]); c.costCluster01=0;
      c.benefit=w.wd*c.d01+w.wg*c.g01; c.costBase=(w.wp*c.costConstr01+w.wn*c.costNear01);
      c.scoreBase=c.benefit-c.costBase; c.score=c.scoreBase;
    }
  }
  function violatesSpread(list){
    if(!document.getElementById("ckSpread").checked) return false;
    const minM=Math.max(0,num(document.getElementById("minSpacing").value,700));
    if(minM<=0) return false;
    for(let i=0;i<list.length;i++) for(let j=i+1;j<list.length;j++) if(distFast(list[i],list[j])<minM) return true;
    return false;
  }
  function applyClusterCosts(sel){
    const w=getWeights(), minM=Math.max(1,num(document.getElementById("minSpacing").value,700));
    for(const c of sel){
      let bestSq=Infinity;
      for(const s of sel){if(s===c)continue;const dSq=distSqFast(c,s);if(dSq<bestSq)bestSq=dSq;}
      const bestD=Number.isFinite(bestSq)?Math.sqrt(bestSq):NaN;
      c.minDistToSelectedM=bestD;
      c.costCluster01=(sel.length<=1||!Number.isFinite(bestD))?0:clamp01(1-(bestD/minM));
      c.cost=clamp01(c.costBase+w.wc*c.costCluster01); c.score=c.benefit-c.cost;
    }
  }
  function repairSolution(sol,P){
    const out=[],used=new Set();
    // Force-include locked candidates first (that are in active candPts)
    for(const lk of lockedSet){
      if(used.has(lk) || !candPts.includes(lk)) continue;
      out.push(lk); used.add(lk);
      if(out.length>=P) return out.slice(0,P);
    }
    // Then add from proposed solution
    for(const x of (sol||[])){if(!x||used.has(x)||!candPts.includes(x))continue;const t=out.concat([x]);if(violatesSpread(t))continue;used.add(x);out.push(x);if(out.length>=P)break;}
    let guard=0;while(out.length<P&&guard++<50000){const c=candPts[Math.floor(Math.random()*candPts.length)];if(used.has(c))continue;const t=out.concat([c]);if(violatesSpread(t))continue;used.add(c);out.push(c);}
    return out.slice(0,P);
  }
  function redundancyAvgNearestSelected(sel){
    if(sel.length<2)return NaN; const ds=[];
    for(const a of sel){let b2=Infinity;for(const b of sel){if(a===b)continue;const dSq=distSqFast(a,b);if(dSq<b2)b2=dSq;}if(Number.isFinite(b2))ds.push(Math.sqrt(b2));}
    return ds.length?ds.reduce((a,b)=>a+b,0)/ds.length:NaN;
  }
  function avgDistToExisting(sel){
    const arr=sel.map(x=>num(x.distToExistingM,NaN)).filter(Number.isFinite);
    return arr.length?arr.reduce((a,b)=>a+b,0)/arr.length:NaN;
  }

  // Worst-served cache
  function buildWorstServedCache(demandPoints){
    const thrSq=Math.pow(getCoverageThresholdDistM(),2);
    const pct=Math.max(1,Math.min(50,Math.floor(num(document.getElementById("worstPct").value,20))));
    const agg=new Map();
    for(const c of demandPoints){
      const code=c.lsoaCode||""; if(!code) continue;
      const w=Math.max(0,num(c.demandRaw,1));
      if(!agg.has(code)) agg.set(code,{totW:0,covCurW:0});
      const rec=agg.get(code); rec.totW+=w;
      if((Number.isFinite(c.distToExistingSq)?c.distToExistingSq:Infinity)<=thrSq) rec.covCurW+=w;
    }
    const rows=[];
    for(const [code,v] of agg.entries()) rows.push({code,totW:v.totW,covCurW:v.covCurW,covCur01:v.totW>0?v.covCurW/v.totW:0});
    rows.sort((a,b)=>a.covCur01-b.covCur01);
    const k=Math.max(1,Math.floor(rows.length*(pct/100))); const worstRows=rows.slice(0,k);
    const set=new Set(worstRows.map(r=>r.code));
    const currentAgg=new Map(); for(const r of worstRows) currentAgg.set(r.code,{totW:r.totW,covCurW:r.covCurW,covCur01:r.covCur01});
    worstCache={set,codes:worstRows.map(r=>r.code),currentAgg,pct};
    return worstCache;
  }
  function computePlanMetrics(sel,demandPoints,cache){
    const thrSq=Math.pow(getCoverageThresholdDistM(),2);
    let totalW=0,coveredW=0;const afterCovW=new Map();
    for(const c of demandPoints){
      const w=Math.max(0,num(c.demandRaw,1)); totalW+=w;
      const exSq=Number.isFinite(c.distToExistingSq)?c.distToExistingSq:Infinity;
      let bestNewSq=Infinity; for(const s of sel){const dSq=distSqFast(c,s);if(dSq<bestNewSq)bestNewSq=dSq;}
      const bestSq=Math.min(exSq,bestNewSq);
      if(bestSq<=thrSq) coveredW+=w;
      const code=c.lsoaCode||"";
      if(code&&cache.set.has(code)){if(!afterCovW.has(code))afterCovW.set(code,0);if(bestSq<=thrSq)afterCovW.set(code,afterCovW.get(code)+w);}
    }
    const covAfter01=totalW>0?coveredW/totalW:0;
    let minImp=Infinity,avgImpSum=0,cnt=0;
    for(const code of cache.codes){
      const cur=cache.currentAgg.get(code); if(!cur||cur.totW<=0) continue;
      const imp=(afterCovW.get(code)||0)/cur.totW-cur.covCur01;
      minImp=Math.min(minImp,imp); avgImpSum+=imp; cnt++;
    }
    if(!Number.isFinite(minImp)) minImp=0;
    return {covAfter01,minImprove:minImp,avgImprove:cnt>0?avgImpSum/cnt:0};
  }

  // Equity evaluation
  function getEquityDir(){ return String(document.getElementById("equityDir").value||"highNeedHigh"); }
  function equityNeed01FromE01(e01){ const v=clamp01(num(e01,0.5)); return (getEquityDir()==="highNeedLow")?(1-v):v; }
  function computeEquityGroupsFromLSOA(){
    if(!lsoaIndex.length) return;
    const eN=normalize01(lsoaIndex.map(r=>r.equityRaw)); const needVals=[];
    for(const r of lsoaIndex){r.equity01=eN.norm(num(r.equityRaw,0));r.need01=equityNeed01FromE01(r.equity01);needVals.push(r.need01);}
    needVals.sort((a,b)=>a-b);
    const q=(p)=>{if(!needVals.length)return 0.5;return needVals[Math.max(0,Math.min(needVals.length-1,Math.floor(p*(needVals.length-1))))];};
    const t1=q(0.20),t2=q(0.40),t3=q(0.60),t4=q(0.80);
    for(const r of lsoaIndex){const v=r.need01;r.equityGroup=v>t4?5:v>t3?4:v>t2?3:v>t1?2:1;}
    for(const c of candPts){const rec=c.lsoaCode?lsoaByCodeMap.get(c.lsoaCode):null;c.equityGroup=rec?rec.equityGroup:3;c.need01=equityNeed01FromE01(c.e01);}
  }
  function computeEquityWeightedCoverage(sel,demandPoints){
    if(!sel.length||!demandPoints.length)return 0;
    const thrSq=Math.pow(getCoverageThresholdDistM(),2);
    let covW=0,totW=0;
    for(const c of demandPoints){
      const dW=Math.max(0,num(c.demandRaw,1)),eqW=(0.2+0.8*equityNeed01FromE01(c.e01)),w=dW*eqW; totW+=w;
      const exSq=Number.isFinite(c.distToExistingSq)?c.distToExistingSq:Infinity;
      let bestSq=Infinity;for(const s of sel){const d=distSqFast(c,s);if(d<bestSq)bestSq=d;}
      if(Math.min(exSq,bestSq)<=thrSq)covW+=w;
    }
    return totW>0?covW/totW:0;
  }
  function computeEquityDisparityQ5Q1(sel,demandPoints){
    if(!sel.length||!demandPoints.length) return {diff:NaN};
    const thrSq=Math.pow(getCoverageThresholdDistM(),2);
    const total=Array(6).fill(0),covered=Array(6).fill(0);
    for(const c of demandPoints){
      const g=Math.max(1,Math.min(5,Math.floor(num(c.equityGroup,3)))),w=Math.max(0,num(c.demandRaw,1));
      total[g]+=w;
      const exSq=Number.isFinite(c.distToExistingSq)?c.distToExistingSq:Infinity;
      let bestSq=Infinity;for(const s of sel){const d=distSqFast(c,s);if(d<bestSq)bestSq=d;}
      if(Math.min(exSq,bestSq)<=thrSq) covered[g]+=w;
    }
    const q1=total[1]>0?covered[1]/total[1]:NaN, q5=total[5]>0?covered[5]/total[5]:NaN;
    return {q1,q5,diff:(Number.isFinite(q1)&&Number.isFinite(q5))?(q5-q1):NaN};
  }

  // ---- NEW: Continuous (non-saturating) KPIs ----

  // Demand-weighted average access distance (meters)
  // Unlike binary coverage, this ALWAYS differentiates â€” lower is better
  function computeDemandWeightedAvgDist(sel, demandPoints){
    if(!sel.length || !demandPoints.length) return NaN;
    let totalW=0, distWSum=0;
    for(const c of demandPoints){
      const w = Math.max(0, num(c.demandRaw, 1));
      totalW += w;
      // best distance to any facility (existing + new)
      const exSq = Number.isFinite(c.distToExistingSq) ? c.distToExistingSq : Infinity;
      let bestSq = exSq;
      for(const s of sel){ const dSq=distSqFast(c,s); if(dSq<bestSq) bestSq=dSq; }
      distWSum += w * Math.sqrt(bestSq);
    }
    return totalW > 0 ? distWSum / totalW : NaN;
  }

  // Max distance to nearest facility (worst-case access) â€” lower is better
  function computeMaxAccessDist(sel, demandPoints){
    if(!sel.length || !demandPoints.length) return NaN;
    let maxDist = 0;
    for(const c of demandPoints){
      const exSq = Number.isFinite(c.distToExistingSq) ? c.distToExistingSq : Infinity;
      let bestSq = exSq;
      for(const s of sel){ const dSq=distSqFast(c,s); if(dSq<bestSq) bestSq=dSq; }
      const d = Math.sqrt(bestSq);
      if(d > maxDist) maxDist = d;
    }
    return maxDist;
  }

  // Demand-weighted p90 access distance (90th percentile) â€” lower is better
  function computeP90AccessDist(sel, demandPoints){
    if(!sel.length || !demandPoints.length) return NaN;
    const dists = [];
    for(const c of demandPoints){
      const exSq = Number.isFinite(c.distToExistingSq) ? c.distToExistingSq : Infinity;
      let bestSq = exSq;
      for(const s of sel){ const dSq=distSqFast(c,s); if(dSq<bestSq) bestSq=dSq; }
      dists.push(Math.sqrt(bestSq));
    }
    dists.sort((a,b)=>a-b);
    const idx = Math.min(dists.length-1, Math.floor(0.90 * dists.length));
    return dists[idx];
  }

  // Full metrics for a solution
  function computeFullMetrics(sel, demandPoints, cache){
    if(!sel || !sel.length) return null;
    const m = computePlanMetrics(sel, demandPoints, cache);
    const avgScore = sel.reduce((a,b)=>a+num(b.score,0),0)/sel.length;
    const dex = avgDistToExisting(sel);
    const red = redundancyAvgNearestSelected(sel);
    const eqCov = computeEquityWeightedCoverage(sel, demandPoints);
    const eqDisp = computeEquityDisparityQ5Q1(sel, demandPoints);
    const dwAvgDist = computeDemandWeightedAvgDist(sel, demandPoints);
    const maxAccess = computeMaxAccessDist(sel, demandPoints);
    const p90Access = computeP90AccessDist(sel, demandPoints);
    return {
      cov: m.covAfter01, wsMin: m.minImprove, wsAvg: m.avgImprove,
      avgScore, dex, red, eqCov, eqDisp: eqDisp.diff,
      dwAvgDist, maxAccess, p90Access
    };
  }

  // ===============================
  // 6b) MULTI-RUN GA INFRASTRUCTURE
  // ===============================
  function getGARuns(){ return Math.max(1, Math.min(20, Math.floor(num(document.getElementById("gaRuns").value, 5)))); }

  // Run GA N times, return { allMetrics[], bestRun:{sol,metrics}, medianMetrics, stdMetrics }
  function runGAMultiple(P, seedSol, demandPoints, cache, mode, N){
    const allSolutions = [];
    const allMetrics = [];

    for(let r=0; r<N; r++){
      const sol = runGA(P, seedSol, demandPoints, cache, mode);
      const m = computeFullMetrics(sol, demandPoints, cache);
      allSolutions.push(sol);
      allMetrics.push(m);
    }

    // Find the best single run by majority-of-KPIs
    const entries = allMetrics.map((m,i) => ({label:String(i), metrics:m}));
    const {bestIdx} = pickBestFromMetrics(entries);

    // Compute median and std for each KPI key
    const medianMetrics = {};
    const stdMetrics = {};
    for(const kpi of KPI_DEFS){
      const vals = allMetrics.map(m => m ? m[kpi.key] : NaN).filter(Number.isFinite);
      medianMetrics[kpi.key] = computeMedian(vals);
      stdMetrics[kpi.key] = computeStd(vals);
    }

    return {
      allMetrics,
      bestRun: { sol: allSolutions[bestIdx], metrics: allMetrics[bestIdx] },
      medianMetrics,
      stdMetrics,
      N
    };
  }

  function computeMedian(arr){
    if(!arr.length) return NaN;
    const sorted = arr.slice().sort((a,b)=>a-b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0 ? (sorted[mid-1]+sorted[mid])/2 : sorted[mid];
  }
  function computeStd(arr){
    if(arr.length < 2) return 0;
    const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
    const sqDiffs = arr.map(v => (v-mean)*(v-mean));
    return Math.sqrt(sqDiffs.reduce((a,b)=>a+b,0)/(arr.length-1));
  }

  // Format Ïƒ values appropriately for each KPI type
  function fmtSigma(kpi, sigma){
    if(!Number.isFinite(sigma) || sigma < 1e-6) return null;
    // Match the scale of the main formatter
    if(kpi.fmt === fmtPct) return (sigma*100).toFixed(1);      // Ïƒ of 0.003 â†’ "0.3"
    if(kpi.fmt === fmtPP)  return (sigma*100).toFixed(1);      // Ïƒ of 0.012 â†’ "1.2"
    if(kpi.fmt === fmtInt) return String(Math.round(sigma));   // Ïƒ of 42.3 â†’ "42"
    // default: match the main format's decimal places
    return sigma.toFixed(3);
  }

  // Render comparison table that supports both single-run and multi-run entries
  // Each entry: { label, metrics, stdMetrics? (if multi-run) }
  function renderComparisonTableV2(tbodyId, entries, kpiDefs){
    const tbody = document.getElementById(tbodyId);
    tbody.innerHTML = "";
    const EPS = 1e-6;

    for(const kpi of kpiDefs){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td style="font-weight:700;">${kpi.name}</td>`;

      const vals = entries.map(e => e.metrics ? e.metrics[kpi.key] : NaN);
      const finite = vals.filter(Number.isFinite);
      const allEqual = finite.length > 0 && finite.every(v => Math.abs(v - finite[0]) < EPS);

      let bestIdx = -1;
      if(!allEqual && finite.length > 0){
        let bestVal = kpi.higherIsBetter ? -Infinity : Infinity;
        for(let i=0;i<vals.length;i++){
          if(!Number.isFinite(vals[i])) continue;
          if(kpi.higherIsBetter ? (vals[i]>bestVal+EPS) : (vals[i]<bestVal-EPS)){ bestVal=vals[i]; bestIdx=i; }
        }
      }

      for(let i=0;i<entries.length;i++){
        const td = document.createElement("td");
        const mainText = kpi.fmt(vals[i]);

        if(entries[i].stdMetrics){
          const sigmaStr = fmtSigma(kpi, entries[i].stdMetrics[kpi.key]);
          if(sigmaStr){
            td.innerHTML = `${escapeHtml(mainText)} <span style="color:#9ca3af;font-size:10px;">Â±${sigmaStr}</span>`;
          } else {
            td.textContent = mainText;
          }
        } else {
          td.textContent = mainText;
        }

        if(i===bestIdx && bestIdx>=0) td.className = "win";
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
  }
  // ===============================
  // 6c) SCENARIO EDITING
  // ===============================
  function setEditMode(mode){
    editMode = mode;
    const bar = document.getElementById("editBar");
    bar.classList.remove("active-add","active-exclude","active-lock");

    document.getElementById("modeNavigate").className = "modeBtn" + (mode==="navigate"?" sel-navigate":"");
    document.getElementById("modeAdd").className = "modeBtn" + (mode==="add"?" sel-add":"");
    document.getElementById("modeExclude").className = "modeBtn" + (mode==="exclude"?" sel-exclude":"");
    document.getElementById("modeLock").className = "modeBtn" + (mode==="lock"?" sel-lock":"");

    document.body.classList.remove("cursor-add","cursor-exclude","cursor-lock");

    const hints = {
      navigate: "Navigate mode â€” click map to view info.",
      add: "Add mode â€” click map to place a new candidate site.",
      exclude: "Exclude mode â€” click a candidate (orange dot) to exclude/restore it.",
      lock: "Lock mode â€” click a candidate to force-include/unlock it in all plans."
    };
    document.getElementById("editModeHint").textContent = hints[mode] || "";

    if(mode==="add"){ bar.classList.add("active-add"); document.body.classList.add("cursor-add"); }
    else if(mode==="exclude"){ bar.classList.add("active-exclude"); document.body.classList.add("cursor-exclude"); }
    else if(mode==="lock"){ bar.classList.add("active-lock"); document.body.classList.add("cursor-lock"); }
  }

  function updateEditCounts(){
    const active = candPts.filter(c => !excludedSet.has(c));
    const customs = candPts.filter(c => c._custom);
    document.getElementById("countCustom").textContent = `+${customs.length} added`;
    document.getElementById("countExcluded").textContent = `${excludedSet.size} excluded`;
    document.getElementById("countLocked").textContent = `${lockedSet.size} locked`;
    document.getElementById("k_candidates").textContent = String(active.length);
  }

  function addEditLog(msg){
    editLogEntries.push(msg);
    const el = document.getElementById("editLog");
    el.style.display = "block";
    // keep last 20
    if(editLogEntries.length > 20) editLogEntries = editLogEntries.slice(-20);
    el.innerHTML = editLogEntries.map(m => `<div>${escapeHtml(m)}</div>`).join("");
    el.scrollTop = el.scrollHeight;
  }

  function findNearestCandidate(lat, lng, maxDistM){
    const click = attachRad({lat, lng});
    let best = null, bestD = Infinity;
    for(const c of candPts){
      const d = distFast(click, c);
      if(d < bestD){ bestD = d; best = c; }
    }
    return (best && bestD <= maxDistM) ? { cand: best, distM: bestD } : null;
  }

  function addCustomCandidate(lat, lng){
    const ll = new google.maps.LatLng(lat, lng);
    const rec = joinPointToLSOA(ll);
    customCount++;
    const c = attachRad({
      lat, lng,
      name: `Custom-${customCount}`,
      _custom: true,
      lsoaCode: rec ? rec.code : "",
      demandRaw: rec ? num(rec.demandRaw, 1) : 1,
      equityRaw: rec ? num(rec.equityRaw, 0) : 0,
      penaltyRaw: rec ? num(rec.penaltyRaw, 0) : 0,
      gapRaw: 0,
      distToExistingM: NaN, distToExistingSq: Infinity,
      d01:0, e01:0, g01:0, benefit:0, costBase:0, cost:0,
      costConstr01:0, costNear01:0, costCluster01:0, scoreBase:0, score:0
    });
    candPts.push(c);

    // Add to map layer
    const fc = { type:"FeatureCollection", features:[{
      type:"Feature",
      geometry:{ type:"Point", coordinates:[lng, lat] },
      properties:{ name: c.name, _custom:true, _idx: candPts.length-1 }
    }]};
    candLayer.addGeoJson(fc);

    addEditLog(`+ Added ${c.name} at (${lat.toFixed(4)}, ${lng.toFixed(4)}) in LSOA ${c.lsoaCode||"none"}`);
    updateEditCounts();
    refreshCandLayerStyle();
  }

  function toggleExclude(cand){
    if(!cand) return;
    if(excludedSet.has(cand)){
      excludedSet.delete(cand);
      lockedSet.delete(cand); // can't be locked if excluded
      addEditLog(`â†© Restored ${cand.name||"candidate"} (LSOA: ${cand.lsoaCode||"?"})`);
    } else {
      excludedSet.add(cand);
      lockedSet.delete(cand);
      addEditLog(`âœ• Excluded ${cand.name||"candidate"} (LSOA: ${cand.lsoaCode||"?"})`);
    }
    updateEditCounts();
    refreshCandLayerStyle();
  }

  function toggleLock(cand){
    if(!cand) return;
    if(excludedSet.has(cand)){
      // Un-exclude first, then lock
      excludedSet.delete(cand);
    }
    if(lockedSet.has(cand)){
      lockedSet.delete(cand);
      addEditLog(`ðŸ”“ Unlocked ${cand.name||"candidate"} (LSOA: ${cand.lsoaCode||"?"})`);
    } else {
      lockedSet.add(cand);
      addEditLog(`ðŸ”’ Locked ${cand.name||"candidate"} â€” will be force-included (LSOA: ${cand.lsoaCode||"?"})`);
    }
    updateEditCounts();
    refreshCandLayerStyle();
  }

  function resetEdits(){
    excludedSet.clear();
    lockedSet.clear();
    // Remove custom candidates
    const origLen = candPts.filter(c => !c._custom).length;
    candPts = candPts.filter(c => !c._custom);
    customCount = 0;
    editLogEntries = [];
    document.getElementById("editLog").style.display = "none";
    document.getElementById("editLog").innerHTML = "";

    // Rebuild candidate layer from scratch
    clearLayer(candLayer);
    const fc = { type:"FeatureCollection", features: candPts.map((c,i) => ({
      type:"Feature",
      geometry:{ type:"Point", coordinates:[c.lng, c.lat] },
      properties:{ name: c.name||"", _idx: i }
    }))};
    candLayer.addGeoJson(fc);

    updateEditCounts();
    refreshCandLayerStyle();
    setEditMode("navigate");
    addEditLog("â†º All edits reset.");
  }

  function refreshCandLayerStyle(){
    if(!candLayer) return;
    candLayer.setStyle(ft => {
      const idx = ft.getProperty("_idx");
      const hov = !!ft.getProperty("_hover");
      const c = (idx !== undefined && idx < candPts.length) ? candPts[idx] : null;
      const isCustom = ft.getProperty("_custom") || (c && c._custom);
      const isExcluded = c && excludedSet.has(c);
      const isLocked = c && lockedSet.has(c);

      if(isExcluded){
        return { icon: iconCircle("#d1d5db", hov?6:5, 1), zIndex:600 }; // grey
      }
      if(isLocked){
        return { icon: iconCircle("#f59e0b", hov?9:8, hov?4:3), zIndex:750 }; // gold, larger
      }
      if(isCustom){
        return { icon: iconCircle("#10b981", hov?8:7, hov?4:3), zIndex:720 }; // green
      }
      return { icon: iconCircle("#f59e0b", hov?7:6, hov?3:2), zIndex:700 }; // default orange
    });
  }

  // Get candidate index from map click proximity
  function findCandIdxNearClick(lat, lng){
    const clickP = attachRad({lat, lng});
    const z = map ? map.getZoom() : 12;
    const threshold = Math.max(30, Math.min(500, 40 * Math.pow(2, 14 - z)));
    let bestIdx = -1, bestD = Infinity;
    for(let i=0; i<candPts.length; i++){
      const d = distFast(clickP, candPts[i]);
      if(d < bestD){ bestD = d; bestIdx = i; }
    }
    return (bestIdx >= 0 && bestD <= threshold) ? bestIdx : -1;
  }

  // Run optimization with only active (non-excluded) candidates
  // Temporarily swaps candPts, runs fn, restores
  function withActiveCandidates(fn){
    const saved = candPts;
    candPts = saved.filter(c => !excludedSet.has(c));
    try { return fn(); }
    finally { candPts = saved; }
  }

  // ===============================
  // 7) LSOA BASELINE
  // ===============================
  function runBaselineLSOA(P, mode){
    // Locked candidates are always included first
    const lockedActive = [...lockedSet].filter(c => candPts.includes(c));

    if(mode === "greedy"){
      const pool=candPts.slice().sort((a,b)=>b.scoreBase-a.scoreBase);
      const picked=[...lockedActive]; const usedSet=new Set(picked);
      // Remove locked from pool
      const remaining = pool.filter(c => !usedSet.has(c));
      while(picked.length<P&&remaining.length){
        let bestIdx=-1,bestScore=-Infinity;
        for(let i=0;i<remaining.length;i++){const c=remaining[i];const trial=picked.concat([c]);if(violatesSpread(trial))continue;if(c.scoreBase>bestScore){bestScore=c.scoreBase;bestIdx=i;}}
        if(bestIdx===-1)break; picked.push(remaining.splice(bestIdx,1)[0]);
      }
      const rep=repairSolution(picked,P); applyClusterCosts(rep); rep.sort((a,b)=>b.score-a.score); return rep;
    }
    // rank mode â€” locked first, then fill by score
    const usedSet = new Set(lockedActive);
    const rest = candPts.slice().sort((a,b)=>b.scoreBase-a.scoreBase).filter(c=>!usedSet.has(c));
    const picked = [...lockedActive, ...rest].slice(0,P);
    applyClusterCosts(picked); picked.sort((a,b)=>b.score-a.score); return picked;
  }

  // ===============================
  // 8) GA
  // ===============================
  function randInt(n){ return Math.floor(Math.random()*n); }
  function makeRandomSolution(P){ return repairSolution([],P); }
  function crossover(a,b,P){
    const pool=[],seen=new Set();
    for(const x of a){if(!seen.has(x)){pool.push(x);seen.add(x);}}
    for(const x of b){if(!seen.has(x)){pool.push(x);seen.add(x);}}
    for(let i=pool.length-1;i>0;i--){const j=randInt(i+1);[pool[i],pool[j]]=[pool[j],pool[i]];}
    return repairSolution(pool,P);
  }
  function mutate(sol,P,mutRate){
    const out=(sol||[]).slice();
    for(let i=0;i<out.length;i++){
      if(Math.random()>mutRate)continue;
      let guard=0;while(guard++<2000){
        const c=candPts[randInt(candPts.length)];if(out.includes(c))continue;
        const trial=out.slice();trial[i]=c;const rep=repairSolution(trial,P);
        if(rep.length===P)return rep;
      }
    }
    return repairSolution(out,P);
  }
  function buildSeededPopulation(P,popSize,seedSol){
    const seedPct=Math.max(0,Math.min(0.8,num(document.getElementById("gaSeedPct").value,0.15)));
    const seedCount=Math.max(0,Math.floor(popSize*seedPct)); const pop=[];
    if(seedCount>0&&seedSol&&seedSol.length){
      const base=repairSolution(seedSol,P);pop.push(base);
      const baseMut=Math.min(0.8,Math.max(0.30,num(document.getElementById("gaMut").value,0.45)+0.10));
      for(let i=1;i<seedCount;i++) pop.push(mutate(base,P,baseMut));
    }
    while(pop.length<popSize) pop.push(makeRandomSolution(P));
    return pop;
  }

  function evalGA(sol,demandPoints,cache,mode){
    applyClusterCosts(sol);
    const m=computePlanMetrics(sol,demandPoints,cache);
    const meanScore=sol.reduce((a,b)=>a+num(b.score,0),0)/Math.max(1,sol.length);
    if(mode==="score") return {sol,keys:[meanScore],dbg:{cov:m.covAfter01,minImp:m.minImprove,meanScore}};
    if(mode==="covScore") return {sol,keys:[m.covAfter01,meanScore],dbg:{cov:m.covAfter01,minImp:m.minImprove,meanScore}};
    return {sol,keys:[m.covAfter01,m.minImprove,meanScore],dbg:{cov:m.covAfter01,minImp:m.minImprove,meanScore}};
  }
  function lexIsBetter(a,b){
    const eps=[1e-4,1e-4,1e-4]; const L=Math.max(a.keys.length,b.keys.length);
    for(let i=0;i<L;i++){const da=a.keys[i]??-Infinity,db=b.keys[i]??-Infinity;if(Math.abs(da-db)>(eps[i]??1e-6)) return da>db;}
    return false;
  }
  function lexSortDesc(a,b){if(lexIsBetter(a,b))return -1;if(lexIsBetter(b,a))return 1;return 0;}

  function runGA(P,seedSol,demandPoints,cache,mode){
    const popSize=Math.max(10,Math.floor(num(document.getElementById("gaPop").value,120)));
    const gens=Math.max(10,Math.floor(num(document.getElementById("gaGen").value,240)));
    const mutRate=clamp01(num(document.getElementById("gaMut").value,0.45));
    const eliteRate=Math.max(0,Math.min(0.5,num(document.getElementById("gaElite").value,0.08)));
    const evalSample=Math.max(10,Math.min(popSize,Math.floor(num(document.getElementById("gaEvalSample").value,80))));

    let pop=buildSeededPopulation(P,popSize,seedSol);
    let bestEval=evalGA(pop[0],demandPoints,cache,mode);

    for(let g=0;g<gens;g++){
      // eval subset
      const subLen=Math.min(evalSample,pop.length);
      const subset=pop.length<=subLen?pop:(() => {const o=pop.slice(0,Math.min(10,pop.length));while(o.length<subLen)o.push(pop[randInt(pop.length)]);return o;})();
      const scored=subset.map(sol=>evalGA(sol,demandPoints,cache,mode)).sort(lexSortDesc);
      if(scored.length&&lexIsBetter(scored[0],bestEval)) bestEval={...scored[0],sol:scored[0].sol.slice()};

      const eliteCount=Math.max(1,Math.floor(eliteRate*popSize));
      const elites=scored.slice(0,Math.min(eliteCount,scored.length)).map(x=>x.sol);
      const pickOne=()=>{let best=null;for(let i=0;i<4;i++){const c=scored[randInt(scored.length)];if(!best||lexIsBetter(c,best))best=c;}return best.sol;};
      const next=elites.slice();
      while(next.length<popSize){
        const p1=scored.length?pickOne():pop[randInt(pop.length)], p2=scored.length?pickOne():pop[randInt(pop.length)];
        next.push(mutate(crossover(p1,p2,P),P,mutRate));
      }
      pop=next;
    }
    const bestSol=repairSolution(bestEval.sol,P);
    applyClusterCosts(bestSol); bestSol.sort((a,b)=>b.score-a.score);
    return bestSol;
  }

  // ===============================
  // 9) MAP LAYER HELPERS
  // ===============================
  function clearLayer(layer){layer.forEach(ft=>layer.remove(ft));}
  function setPlanLayer(layer,sel,planName){
    clearLayer(layer);
    if(!sel||!sel.length)return;
    const fc={type:"FeatureCollection",features:sel.map((c,i)=>({type:"Feature",
      geometry:{type:"Point",coordinates:[c.lng,c.lat]},
      properties:{rank:i+1,plan:planName,name:c.name||"",score:c.score,lsoa:c.lsoaCode||""}}))};
    layer.addGeoJson(fc);
  }
  function focusCandidate(c,label){
    if(!c)return;map.panTo({lat:c.lat,lng:c.lng});map.setZoom(Math.max(map.getZoom(),14));
    info.setContent(`<b>${escapeHtml(label)}</b><br/>name: ${escapeHtml(c.name||"")}<br/>lsoa: ${escapeHtml(c.lsoaCode||"")}<br/>score: ${(c.score??0).toFixed(3)}`);
    info.setPosition({lat:c.lat,lng:c.lng});info.open({map});
  }

  // ===============================
  // 10) COMPARISON TABLE HELPERS
  // ===============================
  function fmtPct(v){ return Number.isFinite(v)? (v*100).toFixed(1)+"%" : "â€“"; }
  function fmtPP(v){ return Number.isFinite(v)? (v*100).toFixed(1)+" pp" : "â€“"; }
  function fmtNum(v,d=1){ return Number.isFinite(v)? v.toFixed(d) : "â€“"; }
  function fmtInt(v){ return Number.isFinite(v)? String(Math.round(v)) : "â€“"; }

  // Given an array of {label, metrics}, render a comparison table body
  // kpiDefs: [{name, key, fmt, higherIsBetter}]

  const KPI_DEFS = [
    { name:"Coverage",                key:"cov",       fmt:fmtPct, higherIsBetter:true },
    { name:"Worst-served min improve", key:"wsMin",    fmt:fmtPP,  higherIsBetter:true },
    { name:"Worst-served avg improve", key:"wsAvg",    fmt:fmtPP,  higherIsBetter:true },
    { name:"Avg score",               key:"avgScore",  fmt:v=>fmtNum(v,3), higherIsBetter:true },
    { name:"Avg dist to existing (m)", key:"dex",      fmt:fmtInt, higherIsBetter:true },
    { name:"Redundancy (avg nearest m)", key:"red",    fmt:fmtInt, higherIsBetter:true },
    { name:"Equity-weighted coverage", key:"eqCov",    fmt:fmtPct, higherIsBetter:true },
    { name:"Equity disparity (Q5âˆ’Q1)", key:"eqDisp",   fmt:fmtPP,  higherIsBetter:false },
    { name:"Demand-wtd avg access (m)", key:"dwAvgDist", fmt:fmtInt, higherIsBetter:false },
    { name:"P90 access distance (m)",  key:"p90Access",  fmt:fmtInt, higherIsBetter:false },
    { name:"Max access distance (m)",  key:"maxAccess",  fmt:fmtInt, higherIsBetter:false },
  ];

  // ===============================
  // 11) EXPORT
  // ===============================
  function downloadText(fn,txt){
    const b=new Blob([txt],{type:"text/plain;charset=utf-8"}),u=URL.createObjectURL(b),a=document.createElement("a");
    a.href=u;a.download=fn;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(u),800);
  }
  function exportCSV(sel,fn){
    const rows=[["rank","name","lat","lng","score","d01","e01","g01","constr01","near01","cluster01","lsoa","dist_to_existing_m"]];
    sel.forEach((c,i)=>rows.push([i+1,(c.name||"").replaceAll('"','""'),c.lat,c.lng,(c.score??0).toFixed(6),(c.d01??0).toFixed(6),(c.e01??0).toFixed(6),(c.g01??0).toFixed(6),(c.costConstr01??0).toFixed(6),(c.costNear01??0).toFixed(6),(c.costCluster01??0).toFixed(6),c.lsoaCode||"",Number.isFinite(c.distToExistingM)?Math.round(c.distToExistingM):""]));
    downloadText(fn,rows.map(r=>r.map(x=>`"${x}"`).join(",")).join("\n"));
  }
  function exportGeoJSON(sel,fn){
    const fc={type:"FeatureCollection",features:sel.map((c,i)=>({type:"Feature",geometry:{type:"Point",coordinates:[c.lng,c.lat]},
      properties:{rank:i+1,name:c.name||"",score:+(c.score??0).toFixed(6),lsoa:c.lsoaCode||""}}))};
    downloadText(fn,JSON.stringify(fc,null,2));
  }

  // ===============================
  // 12) STAGE RUNNERS
  // ===============================
  function commonPrecompute(){
    const userP=Math.max(1,Math.floor(num(document.getElementById("pSel").value,10)));
    const maxP=Math.max(10,Math.floor(num(document.getElementById("maxP").value,150)));
    const P=Math.min(userP,maxP);
    if(P!==userP) document.getElementById("pSel").value=String(P);
    const year=String(document.getElementById("yearSel").value||"2030");
    const target=num(TARGET_BY_YEAR[year],1500), supplyTotal=computeSupplyTotal(), gap=Math.max(0,target-supplyTotal);
    document.getElementById("k_supply").textContent=String(Math.round(supplyTotal));
    document.getElementById("k_target").textContent=String(Math.round(target));
    document.getElementById("k_gap").textContent=String(Math.round(gap));
    document.getElementById("k_candidates").textContent=String(candPts.length);
    if(!candPts.length){setStatus("No candidates loaded.");return null;}
    updateCoverageUI();computeLSOAGapScores();computeDistancesToExisting();scoreCandidatesShared();computeEquityGroupsFromLSOA();updateWeightUI();
    const demandPoints=sampleCandidatesForCoverage();const ws=buildWorstServedCache(demandPoints);
    return {P,year,target,supplyTotal,gap,demandPoints,ws};
  }

  function setStageState(n, state){
    const box = document.getElementById(`stage${n}Box`);
    const num = document.getElementById(`stage${n}Num`);
    box.classList.remove("active","done");
    num.classList.remove("active","done");
    if(state==="active"){box.classList.add("active");num.classList.add("active");}
    else if(state==="done"){box.classList.add("done");num.classList.add("done");}
  }
  function setWinnerTag(id, label, isTie){
    const el=document.getElementById(id);
    el.style.display="inline-flex";
    if(isTie){
      el.innerHTML=`<span class="winnerTag" style="background:#2563eb;">â‰¡ Tie â†’ ${escapeHtml(label)}</span>`;
    } else {
      el.innerHTML=`<span class="winnerTag">â˜… Best: ${escapeHtml(label)}</span>`;
    }
  }

  // Compare metric objects for "overall winner" (majority of KPIs)
  // Returns {bestIdx, isTie, scores}
  function pickBestFromMetrics(entriesArr){
    const scores = entriesArr.map(()=>0);
    const EPS = 1e-6; // tolerance for "equal"

    for(const kpi of KPI_DEFS){
      const vals = entriesArr.map(e => e.metrics ? e.metrics[kpi.key] : NaN);
      const finite = vals.filter(Number.isFinite);
      if(!finite.length) continue;

      // Check if all finite values are essentially equal
      const allEqual = finite.every(v => Math.abs(v - finite[0]) < EPS);
      if(allEqual) continue; // skip tied KPIs â€” no one wins

      let bestIdx=-1, bestVal=kpi.higherIsBetter?-Infinity:Infinity;
      for(let i=0;i<vals.length;i++){
        if(!Number.isFinite(vals[i]))continue;
        if(kpi.higherIsBetter?(vals[i]>bestVal+EPS):(vals[i]<bestVal-EPS)){bestVal=vals[i];bestIdx=i;}
      }
      if(bestIdx>=0) scores[bestIdx]++;
    }

    const maxScore = Math.max(...scores);
    const winners = scores.reduce((acc,s,i) => s===maxScore ? acc.concat(i) : acc, []);
    const isTie = (maxScore === 0) || (winners.length > 1);

    // On a tie, prefer the last entry (more sophisticated method)
    // Stage 1: Greedy+Spacing is last; Stage 2: Lex is last; Stage 3: Hybrid is last
    const bestIdx = isTie ? (entriesArr.length - 1) : winners[0];

    return { bestIdx, isTie, scores };
  }

  // STAGE 1
  function runStage1(){
    withActiveCandidates(()=>{
    const ctx=commonPrecompute(); if(!ctx)return;
    setStageState(1,"active"); setStatus("Running Stage 1 â€” LSOA Rank vs Greedyâ€¦");
    const t0=performance.now();

    results.lsoaRank = runBaselineLSOA(ctx.P, "rank");
    results.lsoaGreedy = runBaselineLSOA(ctx.P, "greedy");

    metrics.lsoaRank = computeFullMetrics(results.lsoaRank, ctx.demandPoints, ctx.ws);
    metrics.lsoaGreedy = computeFullMetrics(results.lsoaGreedy, ctx.demandPoints, ctx.ws);

    const entries=[{label:"Rank",metrics:metrics.lsoaRank},{label:"Greedy+Spacing",metrics:metrics.lsoaGreedy}];
    renderComparisonTableV2("stage1Body", entries, KPI_DEFS);
    document.getElementById("stage1Results").style.display="block";

    const {bestIdx, isTie} = pickBestFromMetrics(entries);
    bestLSOAMode = bestIdx===0?"rank":"greedy";
    setWinnerTag("stage1Winner", entries[bestIdx].label, isTie);

    // Show best LSOA on map
    finalPlanLSOA = bestIdx===0 ? results.lsoaRank : results.lsoaGreedy;
    setPlanLayer(lsoaPlanLayer, finalPlanLSOA, "LSOA");

    setStageState(1,"done");
    document.getElementById("btnStage2").disabled=false;

    const elapsed=((performance.now()-t0)/1000).toFixed(1);
    document.getElementById("stage1Time").textContent=`${elapsed}s`;
    const lockInfo = lockedSet.size ? ` (${lockedSet.size} locked)` : "";
    const exclInfo = excludedSet.size ? ` (${excludedSet.size} excluded)` : "";
    setStatus(`Stage 1 done (${elapsed}s). Best LSOA: ${entries[bestIdx].label}${isTie?" (tie â€” prefer spacing)":""}${lockInfo}${exclInfo}. Proceed to Stage 2.`);
    }); // end withActiveCandidates
  }

  // STAGE 2
  function runStage2(){
    const N = getGARuns();
    setStageState(2,"active"); setStatus(`Running Stage 2 â€” 3 GA modes Ã— ${N} runs eachâ€¦ (may take a while)`);

    setTimeout(()=>{
      const saved = candPts;
      candPts = saved.filter(c => !excludedSet.has(c));
      try {
      const ctx=commonPrecompute(); if(!ctx){ candPts=saved; return; }
      const t0=performance.now();

      const multiScore    = runGAMultiple(ctx.P, null, ctx.demandPoints, ctx.ws, "score", N);
      const multiCovScore = runGAMultiple(ctx.P, null, ctx.demandPoints, ctx.ws, "covScore", N);
      const multiLex      = runGAMultiple(ctx.P, null, ctx.demandPoints, ctx.ws, "lex", N);

      results.gaScore    = multiScore.bestRun.sol;
      results.gaCovScore = multiCovScore.bestRun.sol;
      results.gaLex      = multiLex.bestRun.sol;

      metrics.gaScore    = multiScore.medianMetrics;
      metrics.gaCovScore = multiCovScore.medianMetrics;
      metrics.gaLex      = multiLex.medianMetrics;

      results._multiGA = { score: multiScore, covScore: multiCovScore, lex: multiLex };

      const entries=[
        {label:"Score",     metrics:multiScore.medianMetrics,    stdMetrics:multiScore.stdMetrics},
        {label:"Covâ†’Score", metrics:multiCovScore.medianMetrics, stdMetrics:multiCovScore.stdMetrics},
        {label:"Lex",       metrics:multiLex.medianMetrics,      stdMetrics:multiLex.stdMetrics}
      ];
      renderComparisonTableV2("stage2Body", entries, KPI_DEFS);
      document.getElementById("stage2Results").style.display="block";
      document.getElementById("stage2RunInfo").textContent = `${N} runs per mode (${N*3} total GA runs)`;

      const {bestIdx, isTie} = pickBestFromMetrics(entries);
      bestGAMode = ["score","covScore","lex"][bestIdx];
      setWinnerTag("stage2Winner", entries[bestIdx].label, isTie);

      finalPlanGA = [results.gaScore,results.gaCovScore,results.gaLex][bestIdx];
      setPlanLayer(gaPlanLayer, finalPlanGA, "GA");

      setStageState(2,"done");
      document.getElementById("btnStage3").disabled=false;

      const lsoaLabel = bestLSOAMode==="rank"?"Rank":"Greedy+Spacing";
      const gaLabel = entries[bestIdx].label;
      document.getElementById("stage3Desc").innerHTML =
        `Seed: <b>LSOA ${lsoaLabel}</b> â†’ Refine: <b>GA ${gaLabel}</b>. Hybrid also runs N times.`;
      document.getElementById("stage3ColA").textContent = `LSOA ${lsoaLabel}`;
      document.getElementById("stage3ColB").textContent = `GA ${gaLabel} (median)`;

      const elapsed=((performance.now()-t0)/1000).toFixed(1);
      document.getElementById("stage2Time").textContent=`${elapsed}s`;
      setStatus(`Stage 2 done (${elapsed}s, ${N}Ã—3 runs). Best GA mode: ${gaLabel}${isTie?" (tie)":""}. Proceed to Stage 3.`);
      } finally { candPts = saved; }
    }, 50);
  }

  // STAGE 3
  function runStage3(){
    const N = getGARuns();
    setStageState(3,"active");
    setStatus(`Running Stage 3 â€” Hybrid (best LSOA seed â†’ best GA mode) Ã— ${N} runsâ€¦`);

    setTimeout(()=>{
      const saved = candPts;
      candPts = saved.filter(c => !excludedSet.has(c));
      try {
      const ctx=commonPrecompute(); if(!ctx){ candPts=saved; return; }
      const t0=performance.now();

      const seedSol = bestLSOAMode==="rank" ? results.lsoaRank : results.lsoaGreedy;
      const seedMetrics = bestLSOAMode==="rank" ? metrics.lsoaRank : metrics.lsoaGreedy;

      const bestGAMedian = {score:metrics.gaScore, covScore:metrics.gaCovScore, lex:metrics.gaLex}[bestGAMode];
      const bestGAStd = results._multiGA ?
        {score:results._multiGA.score.stdMetrics, covScore:results._multiGA.covScore.stdMetrics, lex:results._multiGA.lex.stdMetrics}[bestGAMode] : null;

      const multiHybrid = runGAMultiple(ctx.P, seedSol, ctx.demandPoints, ctx.ws, bestGAMode, N);

      results.hybrid = multiHybrid.bestRun.sol;
      metrics.hybrid = multiHybrid.medianMetrics;
      results._multiHybrid = multiHybrid;

      const entries = [
        {label:"Best LSOA", metrics:seedMetrics},
        {label:"Best GA (median)", metrics:bestGAMedian, stdMetrics:bestGAStd},
        {label:"Hybrid (median)", metrics:multiHybrid.medianMetrics, stdMetrics:multiHybrid.stdMetrics}
      ];
      renderComparisonTableV2("stage3Body", entries, KPI_DEFS);
      document.getElementById("stage3Results").style.display="block";
      document.getElementById("stage3RunInfo").textContent = `Hybrid: ${N} runs; GA (alone) median from Stage 2`;

      const {bestIdx: best3, isTie: tie3} = pickBestFromMetrics(entries);
      setWinnerTag("stage3Winner", entries[best3].label, tie3);

      setPlanLayer(lsoaPlanLayer, seedSol, "LSOA (seed)");
      finalPlanGA = results.hybrid;
      setPlanLayer(gaPlanLayer, results.hybrid, "Hybrid");

      setStageState(3,"done");

      document.getElementById("btnExportFinal").disabled = false;
      document.getElementById("btnExportFinalGeo").disabled = false;

      renderFinalCompare(ctx);
      renderHybridList();

      const elapsed=((performance.now()-t0)/1000).toFixed(1);
      document.getElementById("stage3Time").textContent=`${elapsed}s`;
      setStatus(`All 3 stages complete (${elapsed}s). Hybrid: ${N} runs. Switch to "Final compare" for full overview.`);
      } finally { candPts = saved; }
    }, 50);
  }

  function renderFinalCompare(ctx){
    const gaStd = results._multiGA || {};
    const hybStd = results._multiHybrid || {};

    const entries = [
      {label:"LSOA Rank",    metrics:metrics.lsoaRank},
      {label:"LSOA Greedy",  metrics:metrics.lsoaGreedy},
      {label:"GA Score",     metrics:metrics.gaScore,    stdMetrics: gaStd.score ? gaStd.score.stdMetrics : null},
      {label:"GA Covâ†’Score", metrics:metrics.gaCovScore, stdMetrics: gaStd.covScore ? gaStd.covScore.stdMetrics : null},
      {label:"GA Lex",       metrics:metrics.gaLex,      stdMetrics: gaStd.lex ? gaStd.lex.stdMetrics : null},
      {label:"Hybrid",       metrics:metrics.hybrid,     stdMetrics: hybStd.stdMetrics || null}
    ];
    renderComparisonTableV2("finalBody", entries, KPI_DEFS);
  }

  function renderHybridList(){
    const el=document.getElementById("hybridList"); el.innerHTML="";
    const sel=results.hybrid||[];
    if(!sel.length){el.innerHTML='<div class="item"><div class="muted">No hybrid results yet.</div></div>';return;}
    sel.forEach((c,i)=>{
      const row=document.createElement("div");row.className="item";
      row.innerHTML=`<div class="itemTitle">${i+1}. ${escapeHtml(c.name||"Candidate")}</div>`+
        `<div class="itemMeta">`+
        `<span class="badge" style="border-color:#7c3aed;">score ${(c.score??0).toFixed(3)}</span>`+
        `<span class="badge">LSOA ${escapeHtml(c.lsoaCode||"")}</span>`+
        `<span class="badge">D ${Math.round((c.d01??0)*100)}</span>`+
        `<span class="badge">Gap ${Math.round((c.g01??0)*100)}</span>`+
        `</div>`;
      row.addEventListener("click",()=>focusCandidate(c,"Hybrid plan"));
      el.appendChild(row);
    });
  }

  // Run all 3 stages sequentially
  function runAll(){
    runStage1();
    // Stage 2 and 3 use setTimeout internally, so chain them
    setTimeout(()=>{
      runStage2();
      // Wait for stage 2 to finish (it uses setTimeout 50ms + computation time)
      // Use a polling approach
      const waitForStage2 = setInterval(()=>{
        if(document.getElementById("btnStage3").disabled===false){
          clearInterval(waitForStage2);
          setTimeout(()=>runStage3(), 100);
        }
      }, 200);
    }, 100);
  }

  // ===============================
  // 13) MAP INIT
  // ===============================
  async function initMap(){
    map = new google.maps.Map(document.getElementById("map"), {
      center:{lat:51.4816,lng:-3.1791}, zoom:12,
      mapTypeControl:false, streetViewControl:false, fullscreenControl:true
    });
    info = new google.maps.InfoWindow();

    supplyLayer   = new google.maps.Data({map});
    lsoaLayer     = new google.maps.Data({map});
    candLayer     = new google.maps.Data({map});
    lsoaPlanLayer = new google.maps.Data({map});
    gaPlanLayer   = new google.maps.Data({map});

    supplyLayer.setStyle(ft => {
      const hov=!!ft.getProperty("_hover");
      return { icon:iconCircle("#2563eb",hov?10:8,hov?5:4), zIndex:800 };
    });
    candLayer.setStyle(ft => {
      const hov=!!ft.getProperty("_hover");
      return { icon:iconCircle("#f59e0b",hov?7:6,hov?3:2), zIndex:700 };
    });
    lsoaPlanLayer.setStyle(ft => {
      const hov=!!ft.getProperty("_hover");
      return { icon:iconStar("#ef4444",hov?1.35:1.15), zIndex:9999 };
    });
    gaPlanLayer.setStyle(ft => {
      const hov=!!ft.getProperty("_hover");
      return { icon:iconDiamond("#7c3aed",hov?1.0:0.85), zIndex:9998 };
    });

    function addHover(layer){
      layer.addListener("mouseover",e=>e.feature.setProperty("_hover",true));
      layer.addListener("mouseout",e=>e.feature.setProperty("_hover",false));
    }
    addHover(supplyLayer);addHover(candLayer);addHover(lsoaPlanLayer);addHover(gaPlanLayer);

    let _candClickGuard = false; // prevents map "add" click when clicking a feature

    // Supply layer click info
    supplyLayer.addListener("click",e=>{
      _candClickGuard = true; setTimeout(()=>{ _candClickGuard = false; }, 100);
      if(editMode !== "navigate") return;
      const ft = e.feature;
      const name = ft.getProperty("name")||ft.getProperty("operator")||"";
      const sockets = ft.getProperty("sockets")||ft.getProperty("SocketCount")||"?";
      info.setContent(`<b>Existing charger</b><br/>${escapeHtml(name)}<br/>Sockets: ${sockets}`);
      info.setPosition(e.latLng); info.open({map});
    });

    // Click handlers for plan layers (only in navigate mode)
    lsoaPlanLayer.addListener("click",e=>{
      _candClickGuard = true; setTimeout(()=>{ _candClickGuard = false; }, 100);
      if(editMode !== "navigate") return;
      const ft=e.feature;
      info.setContent(`<b>LSOA Plan</b><br/>Rank: ${ft.getProperty("rank")}<br/>Name: ${escapeHtml(ft.getProperty("name")||"")}<br/>Score: ${num(ft.getProperty("score"),0).toFixed(3)}<br/>LSOA: ${escapeHtml(ft.getProperty("lsoa")||"")}`);
      info.setPosition(e.latLng);info.open({map});
    });
    gaPlanLayer.addListener("click",e=>{
      _candClickGuard = true; setTimeout(()=>{ _candClickGuard = false; }, 100);
      if(editMode !== "navigate") return;
      const ft=e.feature;
      info.setContent(`<b>${escapeHtml(ft.getProperty("plan")||"GA")} Plan</b><br/>Rank: ${ft.getProperty("rank")}<br/>Name: ${escapeHtml(ft.getProperty("name")||"")}<br/>Score: ${num(ft.getProperty("score"),0).toFixed(3)}<br/>LSOA: ${escapeHtml(ft.getProperty("lsoa")||"")}`);
      info.setPosition(e.latLng);info.open({map});
    });
    lsoaLayer.addListener("click",e=>{
      _candClickGuard = true; setTimeout(()=>{ _candClickGuard = false; }, 100);
      if(editMode !== "navigate") return;
      const ft=e.feature;const code=ft.getProperty("LSOA21CD")||ft.getProperty("lsoa21cd")||ft.getProperty("code")||"";
      const gap=num(ft.getProperty("_gapScore"),NaN);
      info.setContent(`<b>LSOA: ${escapeHtml(code)}</b><br/>Gap score: ${Number.isFinite(gap)?gap.toFixed(3):"n/a"}`);
      info.setPosition(e.latLng);info.open({map});
    });

    // Candidate layer click â€” supports exclude and lock modes
    candLayer.addListener("click",e=>{
      _candClickGuard = true;
      setTimeout(()=>{ _candClickGuard = false; }, 100);

      const ft = e.feature;
      const idx = ft.getProperty("_idx");
      const c = (idx !== undefined && idx < candPts.length) ? candPts[idx] : null;

      if(editMode === "exclude" && c){
        toggleExclude(c);
        return;
      }
      if(editMode === "lock" && c){
        toggleLock(c);
        return;
      }
      // Navigate mode: show info
      if(editMode === "navigate" && c){
        const isEx = excludedSet.has(c) ? " [EXCLUDED]" : "";
        const isLk = lockedSet.has(c) ? " [LOCKED]" : "";
        info.setContent(`<b>Candidate${isEx}${isLk}</b><br/>Name: ${escapeHtml(c.name||"")}<br/>LSOA: ${escapeHtml(c.lsoaCode||"")}<br/>Score: ${(c.scoreBase||0).toFixed(3)}${c._custom?"<br/><i>Custom site</i>":""}`);
        info.setPosition(e.latLng);info.open({map});
      }
    });

    // General map click for "add" mode
    map.addListener("click",e=>{
      if(editMode !== "add") return;
      if(_candClickGuard) return; // Don't add when clicking existing candidate
      const lat = e.latLng.lat();
      const lng = e.latLng.lng();
      if(lat < CARDIFF_BOUNDS.south || lat > CARDIFF_BOUNDS.north ||
         lng < CARDIFF_BOUNDS.west || lng > CARDIFF_BOUNDS.east){
        setStatus("Outside Cardiff bounds â€” cannot add candidate here.");
        return;
      }
      addCustomCandidate(lat, lng);
    });

    styleLSOA();

    // UI wiring
    document.getElementById("ckSupply").addEventListener("change",e=>supplyLayer.setMap(e.target.checked?map:null));
    document.getElementById("ckLSOA").addEventListener("change",e=>lsoaLayer.setMap(e.target.checked?map:null));
    document.getElementById("ckCandidates").addEventListener("change",e=>candLayer.setMap(e.target.checked?map:null));
    document.getElementById("ckLSOAPlan").addEventListener("change",e=>lsoaPlanLayer.setMap(e.target.checked?map:null));
    document.getElementById("ckGAPlan").addEventListener("change",e=>gaPlanLayer.setMap(e.target.checked?map:null));

    document.getElementById("tabStages").addEventListener("click",()=>setTab("stages"));
    document.getElementById("tabGap").addEventListener("click",()=>setTab("gap"));
    document.getElementById("tabCompare").addEventListener("click",()=>setTab("compare"));

    document.getElementById("btnRunAll").addEventListener("click", runAll);
    document.getElementById("btnStage1").addEventListener("click", runStage1);
    document.getElementById("btnStage2").addEventListener("click", runStage2);
    document.getElementById("btnStage3").addEventListener("click", runStage3);

    document.getElementById("btnExportFinal").addEventListener("click",()=>{if(results.hybrid)exportCSV(results.hybrid,"hybrid_final.csv");});
    document.getElementById("btnExportFinalGeo").addEventListener("click",()=>{if(results.hybrid)exportGeoJSON(results.hybrid,"hybrid_final.geojson");});

    document.getElementById("covMode").addEventListener("change",updateCoverageUI);

    try{
      setStatus("Loading GeoJSONâ€¦");
      const [supply,lsoa,candidates]=await Promise.all([loadGeoJSON(DATA_URLS.supply),loadGeoJSON(DATA_URLS.lsoa),loadGeoJSON(DATA_URLS.candidates)]);
      supplyLayer.addGeoJson(supply); lsoaLayer.addGeoJson(lsoa);
      // Don't add candidates directly â€” we rebuild with _idx below

      // Build LSOA index
      lsoaIndex=(lsoa.features||[]).map(f=>{
        const props=f.properties||{};const code=getProp(props,FIELD.code,"LSOA");
        const pop=num(getProp(props,FIELD.pop,null),NaN);const demandRaw=Number.isFinite(pop)?pop:num(getProp(props,FIELD.demand,1),1);
        const medAge=num(getProp(props,FIELD.median_age,null),NaN);
        return {code,pop,medianAge:medAge,demandRaw,equityRaw:computeEquityFromProps(props,medAge),penaltyRaw:computePenaltyFromProps(props),
          polygons:makePolygonsFromGeometry(f.geometry),feature:null,supplyRaw:0,gap01:0};
      });

      lsoaByCodeMap=new Map(lsoaIndex.map(r=>[r.code,r]));
      lsoaLayer.forEach(ft=>{
        const propsLike={LSOA21CD:ft.getProperty("LSOA21CD"),lsoa21cd:ft.getProperty("lsoa21cd"),LSOA11CD:ft.getProperty("LSOA11CD"),lsoa11cd:ft.getProperty("lsoa11cd"),code:ft.getProperty("code"),id:ft.getProperty("id")};
        const code=getProp(propsLike,FIELD.code,null);
        if(code&&lsoaByCodeMap.has(code)){const rec=lsoaByCodeMap.get(code);rec.feature=ft;ft.setProperty("code",rec.code);}
      });

      // Supply cache
      supplyPts=[];
      for(const f of (supply.features||[])){
        if(!f.geometry||f.geometry.type!=="Point")continue;
        const coords=f.geometry.coordinates||[];const lng=coords[0],lat=coords[1];
        if(typeof lat!=="number"||typeof lng!=="number")continue;
        if(looksLike27700(lng,lat))continue;
        const props=f.properties||{};const sockets=num(getProp(props,FIELD.sockets,0),0);
        supplyPts.push(attachRad({lat,lng,sockets:sockets||1}));
      }

      // Candidate cache + LSOA join
      candPts=[];
      for(const f of (candidates.features||[])){
        if(!f.geometry||f.geometry.type!=="Point")continue;
        const coords=f.geometry.coordinates||[];const lng=coords[0],lat=coords[1];
        if(typeof lat!=="number"||typeof lng!=="number")continue;
        if(looksLike27700(lng,lat))continue;
        const props=f.properties||{};
        const name=getProp(props,["name","id","site","label","LSOA21NM","LSOA11NM"],"Candidate");
        const ll=new google.maps.LatLng(lat,lng); const rec=joinPointToLSOA(ll);
        candPts.push(attachRad({lat,lng,name,lsoaCode:rec?rec.code:"",
          demandRaw:rec?num(rec.demandRaw,1):1,equityRaw:rec?num(rec.equityRaw,0):0,
          penaltyRaw:rec?num(rec.penaltyRaw,0):0,gapRaw:0,
          distToExistingM:NaN,distToExistingSq:Infinity,
          d01:0,e01:0,g01:0,benefit:0,costBase:0,cost:0,
          costConstr01:0,costNear01:0,costCluster01:0,scoreBase:0,score:0}));
      }

      computeLSOAGapScores(); styleLSOA();

      // Store original candidates snapshot for reset
      candPtsOriginal = candPts.slice();

      // Build candidate layer with _idx property for editing support
      const candFC = { type:"FeatureCollection", features: candPts.map((c,i) => ({
        type:"Feature",
        geometry:{ type:"Point", coordinates:[c.lng, c.lat] },
        properties:{ name: c.name||"", _idx: i }
      }))};
      candLayer.addGeoJson(candFC);
      refreshCandLayerStyle();
      updateEditCounts();

      const year=String(document.getElementById("yearSel").value||"2030");
      const supplyTotal=computeSupplyTotal();
      document.getElementById("k_supply").textContent=String(Math.round(supplyTotal));
      document.getElementById("k_target").textContent=String(Math.round(num(TARGET_BY_YEAR[year],1500)));
      document.getElementById("k_gap").textContent="â€“";
      document.getElementById("k_candidates").textContent=String(candPts.length);

      map.fitBounds(CARDIFF_BOUNDS);
      updateCoverageUI();

      setStatus(
        `Loaded.\nSupply points: ${supplyPts.length}\nLSOA polygons: ${(lsoa.features||[]).length}\nCandidates: ${candPts.length}\n\n`+
        `Click "â–¶ Run All 3 Stages" to execute the cascading experiment,\nor run stages individually with the per-stage buttons.`
      );
    }catch(err){
      console.error(err);setStatus("FAILED.\n"+String(err));alert(String(err));
    }
  }

  window.initMap = initMap;
  (function loadGoogleMaps(){
    const s=document.createElement("script");
    s.src="https://maps.googleapis.com/maps/api/js?key="+encodeURIComponent(GMAPS_KEY)+"&callback=initMap&v=weekly&libraries=geometry&loading=async";
    s.async=true;s.defer=true;document.head.appendChild(s);
  })();
</script>
</body>
</html>