<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cardiff EV Charging – Planner View</title>
  <style>
    html, body { height:100%; margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #map { height:100%; width:100%; }
    #map img { max-width:none !important; }

    .panel{
      position:absolute; top:12px; left:12px; z-index:5;
      background:rgba(255,255,255,0.96);
      border:1px solid #ddd; border-radius:14px;
      padding:12px; width:480px;
      box-shadow:0 4px 18px rgba(0,0,0,0.12);
      max-height: calc(100vh - 24px);
      overflow:auto;
    }
    .title{ font-weight:900; font-size:20px; margin:0 0 10px; }
    .row{ display:flex; align-items:center; gap:10px; margin:8px 0; flex-wrap:wrap; }
    .small{ color:#374151; font-size:12px; }
    .muted{ color:#6b7280; font-size:12px; }
    .btn{
      background:#111827; color:#fff; border:none; border-radius:10px;
      padding:10px 12px; cursor:pointer; font-size:13px; font-weight:900;
    }
    .btn.secondary{ background:#6b7280; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }

    .input, select{
      border:1px solid #e5e7eb; border-radius:10px;
      padding:10px 12px; outline:none; font-size:13px; background:#fff;
    }

    .kpis{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:8px; }
    .card{ border:1px solid #eee; border-radius:12px; padding:10px 12px; background:#fff; }
    .card .h{ font-size:12px; color:#6b7280; margin-bottom:6px; }
    .card .v{ font-size:18px; font-weight:900; color:#111827; }

    .section{ margin-top:10px; padding-top:10px; border-top:1px solid #eee; }
    .pill{
      display:inline-flex; align-items:center;
      border:1px solid #e5e7eb; border-radius:999px;
      padding:6px 10px; font-size:12px; background:#fff;
      cursor:pointer;
    }
    .pill.active{ background:#111827; color:#fff; border-color:#111827; }

    .list{ margin-top:8px; max-height:240px; overflow:auto; border:1px solid #eee; border-radius:12px; background:#fff; }
    .item{ padding:10px 12px; border-bottom:1px solid #f1f5f9; cursor:pointer; }
    .item:hover{ background:#f8fafc; }
    .item:last-child{ border-bottom:none; }
    .itemTitle{ font-weight:900; font-size:13px; margin-bottom:4px; }
    .itemMeta{ font-size:12px; color:#374151; display:flex; gap:10px; flex-wrap:wrap; }
    .badge{
      display:inline-flex; align-items:center;
      padding:2px 8px; border-radius:999px;
      border:1px solid #e5e7eb; font-size:12px; color:#111827;
      background:#fff;
    }

    .status{ margin-top:8px; font-size:12px; color:#111827; white-space:pre-wrap; }
    .legend{ margin-top:10px; font-size:12px; line-height:1.35; }
    .swatch{ display:inline-block; width:12px; height:12px; border-radius:999px; margin-right:8px; border:2px solid rgba(255,255,255,0.9); box-shadow:0 0 0 1px rgba(0,0,0,0.12); }

    /* scoring bars */
    .barRow{ display:flex; align-items:center; gap:10px; margin-top:6px; }
    .barTrack{ flex:1; height:10px; border-radius:999px; background:#eef2ff; overflow:hidden; border:1px solid #e5e7eb; }
    .barFill{ height:100%; }
    .tiny{ font-size:11px; color:#6b7280; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>

<body>
<div id="map"></div>

<div class="panel">
  <div class="title">Planner view (Cardiff)</div>
  <div class="muted">
    Uses: supply + LSOA (<b>enriched with WIMD + census proxies</b>) + demand centroids as candidates.
  </div>

  <div class="section">
    <div style="font-weight:900; margin-bottom:6px;">Scenario (P sites) + scoring (P3/P4)</div>
    <div class="row">
      <label class="small">Target year</label>
      <select id="yearSel">
        <option value="2026">2026</option>
        <option value="2030" selected>2030</option>
        <option value="2035">2035</option>
      </select>

      <label class="small">Add P</label>
      <input id="pSel" class="input" style="width:90px" type="number" min="1" value="10"/>
      <button id="btnRun" class="btn">Run scenario</button>
    </div>

    <div class="row">
      <span class="pill active" id="tabKpi">KPIs</span>
      <span class="pill" id="tabGap">Gap map</span>
      <span class="pill" id="tabScore">Scoring</span>
    </div>

    <div class="row">
      <label class="small"><input id="ckSupply" type="checkbox" checked> Existing chargers</label>
      <label class="small"><input id="ckLSOA" type="checkbox" checked> LSOA boundary</label>
      <label class="small"><input id="ckCandidates" type="checkbox" checked> Candidates (demand points)</label>
      <label class="small"><input id="ckSelected" type="checkbox" checked> Selected (Top P)</label>
    </div>

    <div class="row">
      <button id="btnExportCsv" class="btn secondary" disabled>Export shortlist (CSV)</button>
      <button id="btnExportGeo" class="btn secondary" disabled>Export shortlist (GeoJSON)</button>
      <button id="btnPrint" class="btn secondary">Print</button>
    </div>

    <div class="muted">
      <b>Score (transparent)</b>: <span class="mono">Score = wd·Demand + we·Equity − wp·Penalty</span><br/>
      Demand: population (preferred) → fallback to other demand-like fields.<br/>
      Equity: prefers <span class="mono">equity_proxy / wimd_norm</span> (higher = more deprived / higher priority).<br/>
      Penalty: prefers <span class="mono">parking_constraint</span> (0–1, higher = more constrained), else combines census shares.
    </div>
  </div>

  <!-- Scoring tab panel -->
  <div class="section" id="scorePanel" style="display:none;">
    <div style="font-weight:900; margin-bottom:6px;">Scoring breakdown (P3)</div>
    <div class="muted" id="scoreFormula"></div>

    <div class="row" style="margin-top:10px;">
      <label class="small" style="min-width:105px;">Demand weight</label>
      <input id="wDemand" type="range" min="0" max="1" step="0.01" value="0.60" style="flex:1;">
      <span class="badge" id="wDemandVal">0.60</span>
    </div>

    <div class="row">
      <label class="small" style="min-width:105px;">Equity weight</label>
      <input id="wEquity" type="range" min="0" max="1" step="0.01" value="0.40" style="flex:1;">
      <span class="badge" id="wEquityVal">0.40</span>
    </div>

    <div class="row">
      <label class="small" style="min-width:105px;">Penalty weight</label>
      <input id="wPenalty" type="range" min="0" max="1" step="0.01" value="0.20" style="flex:1;">
      <span class="badge" id="wPenaltyVal">0.20</span>
    </div>

    <div class="muted" style="margin-top:6px;">
      Notes:
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li>Demand / Equity / Penalty all normalized to 0–1 before weighting.</li>
        <li>Demand+Equity are re-normalized to sum to 1 (more interpretable); Penalty is independent.</li>
      </ul>
    </div>

    <div class="kpis" style="margin-top:10px;">
      <div class="card"><div class="h">Avg Demand (Top P)</div><div class="v" id="k_davg">–</div></div>
      <div class="card"><div class="h">Avg Equity (Top P)</div><div class="v" id="k_eavg">–</div></div>
      <div class="card"><div class="h">Avg Penalty (Top P)</div><div class="v" id="k_pavg">–</div></div>
      <div class="card"><div class="h">Avg Score (Top P)</div><div class="v" id="k_savg">–</div></div>
    </div>

    <div class="row" style="justify-content:space-between; margin-top:10px;">
      <div style="font-weight:900;">Top P score decomposition</div>
      <span class="badge" id="scoreCountBadge">0</span>
    </div>

    <div class="list" id="scoreList"></div>
  </div>

  <div class="section">
    <div style="font-weight:900; margin-bottom:6px;">Needs & gap dashboard (P1)</div>
    <div class="kpis">
      <div class="card"><div class="h">Current supply (sockets or points)</div><div class="v" id="k_supply">–</div></div>
      <div class="card"><div class="h">Target sockets (year)</div><div class="v" id="k_target">–</div></div>
      <div class="card"><div class="h">Gap (target - supply)</div><div class="v" id="k_gap">–</div></div>
      <div class="card"><div class="h">Selected sites (Top P)</div><div class="v" id="k_selected">0</div></div>
    </div>
    <div class="status" id="status"></div>
  </div>

  <div class="section">
    <div class="row" style="justify-content:space-between;">
      <div style="font-weight:900;">Shortlist (Top P)</div>
      <span class="badge" id="countBadge">0</span>
    </div>
    <div class="muted" id="emptyHint">Run scenario to generate shortlist.</div>
    <div class="list" id="resultList" style="display:none;"></div>
  </div>

  <div class="legend">
    <b>Legend</b><br/>
    <div><span class="swatch" style="background:#2563eb;"></span>Blue dots: existing chargers</div>
    <div><span class="swatch" style="background:#f59e0b;"></span>Orange dots: candidate demand centroids</div>
    <div><span class="swatch" style="background:#ef4444;"></span>Red stars: selected (Top P)</div>
    <div><span class="swatch" style="background:#7c3aed;"></span>Purple triangles: p10 overlay (optional)</div>
    <div class="muted" style="margin-top:6px;">Gap map colors LSOA by high demand + low provision (P2).</div>
  </div>
</div>

<script>
  // ===============================
  // 0) CONFIG
  // ===============================
  const GMAPS_KEY = "AIzaSyAUproFl8jRStUlFwOKbQ8yh2CjNJ_H2c4";

  // If you want to remove "Show p10 solution overlay", set this to false.
  const ENABLE_P10_OVERLAY = false;

  const BASE = new URL("./", window.location.href);

  const DATA_URLS = {
    supply:     new URL("data/processed/supply_chargers_ocm.geojson", BASE).href,
    // IMPORTANT: use your enriched LSOA (WIMD + census proxies already joined)
    lsoa:       new URL("data/processed/demand_lsoa_cardiff_exact_pop_wgs84_enriched.geojson", BASE).href,
    candidates: new URL("data/processed/demand_points_cardiff_exact_pop_wgs84.geojson", BASE).href,
    solution:   new URL("data/processed/new_sites_p10.geojson", BASE).href
  };

  const CARDIFF_BOUNDS = { north: 51.566, south: 51.410, east: -3.065, west: -3.333 };
  const TARGET_BY_YEAR = { "2026": 700, "2030": 1500, "2035": 2000 };

  // ===============================
  // 1) FIELD MAPS (support enriched properties)
  // ===============================
  const FIELD = {
    // LSOA identity
    code:   ["LSOA21CD","lsoa21cd","LSOA11CD","lsoa11cd","code","id"],

    // Demand proxies
    pop:    ["population","pop","pop_total","Pop","total_pop","Total"],
    demand: ["demand","demand_score","ev_owners","owners","weight"],

    // Equity proxies (WIMD preferred)
    equity_proxy: ["equity_proxy","equity_wimd","equity_norm"],
    wimd_norm:    ["wimd_norm","imd_norm","wimd2019_norm"],
    wimd_rank:    ["wimd_rank","imd_rank","wimd2019_rank"],
    wimd_decile:  ["wimd_decile","imd_decile","wimd2019_decile"],
    median_age:   ["median_age","median age","Median age mid-2024","Median age mid-2023","Median age mid-2022"],

    // Penalty proxies (parking/install constraints)
    parking_constraint: ["parking_constraint","constraint","install_constraint"],
    share_flats:  ["share_flats","pct_flats","flats_share"],
    share_dense:  ["share_dense","pct_dense","dense_share","share_terraced","pct_terraced"],
    share_rented: ["share_rented","pct_rented","rented_share"],
    share_no_car: ["share_no_car","pct_no_car","no_car_share"],

    // supply
    sockets:["sockets","SocketCount","socket_count","connectors","num_sockets","units"],
    name:   ["name","operator","location","Site","address","Address"]
  };

  // fallback weights (sliders override)
  const W = { demand: 0.60, equity: 0.40, penalty: 0.20 };

  // ===============================
  // 2) STATE
  // ===============================
  let map, info;
  let supplyLayer, lsoaLayer, candLayer, selectedLayer, solutionLayer;

  let lsoaIndex = [];   // [{code, demandRaw, equityRaw, penaltyRaw, proxies..., polygons, feature}]
  let supplyPts = [];
  let candPts = [];
  let selected = [];
  let activeTab = "kpi";

  // ===============================
  // 3) UTILS
  // ===============================
  function setStatus(msg){ document.getElementById("status").textContent = msg || ""; }
  function escapeHtml(s){
    return String(s||"").replace(/[&<>"']/g,(c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }
  function num(x, fb=0){ const v=Number(x); return Number.isFinite(v)? v: fb; }
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  // some shares might be in 0..100; convert to 0..1
  function pctTo01(x){
    const v = num(x, NaN);
    if(!Number.isFinite(v)) return NaN;
    return (v > 1.0001) ? clamp01(v/100) : clamp01(v);
  }

  function getProp(props, keys, fb=null){
    for(const k of keys){
      if(props && props[k] !== undefined && props[k] !== null && props[k] !== "") return props[k];
    }
    return fb;
  }

  async function loadGeoJSON(url){
    const res = await fetch(url,{cache:"no-store"});
    if(!res.ok) throw new Error(`Fetch failed: ${res.status} ${url}`);
    return await res.json();
  }

  async function loadGeoJSONOptional(url){
    try{
      return await loadGeoJSON(url);
    }catch(e){
      return null;
    }
  }

  function looksLike27700(lng, lat){
    return Math.abs(lng) > 1000 || Math.abs(lat) > 1000;
  }

  // --- symbols ---
  function iconCircle(fill, scale, strokeW=3){
    return { path: google.maps.SymbolPath.CIRCLE, fillColor:fill, fillOpacity:1,
      strokeColor:"#ffffff", strokeOpacity:1, strokeWeight:strokeW, scale };
  }
  function iconStar(fill){
    return { path:"M 0,-10 L 2,-3 L 10,-3 L 4,1 L 6,9 L 0,4 L -6,9 L -4,1 L -10,-3 L -2,-3 Z",
      fillColor:fill, fillOpacity:0.95, strokeColor:"#ffffff", strokeOpacity:1, strokeWeight:1, scale:1 };
  }
  function iconTriangle(fill){
    return { path: google.maps.SymbolPath.BACKWARD_CLOSED_ARROW, fillColor:fill, fillOpacity:0.95,
      strokeColor:"#ffffff", strokeOpacity:1, strokeWeight:1, scale:6 };
  }

  // ===============================
  // 4) SCORING MEANING (Equity/Penalty)
  // ===============================
  function computeEquityFromProps(props, fallbackMedianAge){
    // priority 1: equity_proxy (already prepared by your join script)
    const equityProxy = getProp(props, FIELD.equity_proxy, null);
    if(equityProxy !== null) return num(equityProxy, 0);

    // priority 2: wimd_norm (0..1, higher = more deprived)
    const wimdNorm = getProp(props, FIELD.wimd_norm, null);
    if(wimdNorm !== null) return num(wimdNorm, 0);

    // priority 3: wimd_rank or decile -> convert to "higher = more deprived"
    const r = num(getProp(props, FIELD.wimd_rank, NaN), NaN);
    if(Number.isFinite(r)){
      // we do not know the national max rank here; we will normalize across Cardiff LSOAs later anyway,
      // so returning raw rank is okay, but we invert direction: smaller rank => higher equity.
      // Use negative rank so that larger raw => "more deprived"
      return -r;
    }

    const d = num(getProp(props, FIELD.wimd_decile, NaN), NaN);
    if(Number.isFinite(d)){
      // decile: 1 most deprived -> equity higher
      return (11 - d) / 10;
    }

    // fallback: median age proxy (your old logic)
    return Number.isFinite(fallbackMedianAge) ? fallbackMedianAge : 0;
  }

  function computePenaltyFromProps(props){
    // priority 1: parking_constraint directly (0..1)
    const pc = getProp(props, FIELD.parking_constraint, null);
    if(pc !== null){
      const v = pctTo01(pc);
      if(Number.isFinite(v)) return v;
    }

    // priority 2: derive from shares (0..1)
    const flats  = pctTo01(getProp(props, FIELD.share_flats, NaN));
    const dense  = pctTo01(getProp(props, FIELD.share_dense, NaN));
    const rented = pctTo01(getProp(props, FIELD.share_rented, NaN));
    const nocar  = pctTo01(getProp(props, FIELD.share_no_car, NaN));

    // If nothing exists, return 0 (no penalty)
    const arr = [flats,dense,rented,nocar].filter(Number.isFinite);
    if(arr.length === 0) return 0;

    // Weighted sum (you can tune these):
    // - flats/dense/rented are strongest "install/parking constraint"
    // - no_car is weaker (adoption/priority proxy)
    const wFlats = 0.40, wDense = 0.25, wRented = 0.25, wNoCar = 0.10;
    const val =
      (Number.isFinite(flats)  ? wFlats*flats  : 0) +
      (Number.isFinite(dense)  ? wDense*dense  : 0) +
      (Number.isFinite(rented) ? wRented*rented: 0) +
      (Number.isFinite(nocar)  ? wNoCar*nocar  : 0);

    return clamp01(val);
  }

  // ===============================
  // 5) SCORING UI HELPERS
  // ===============================
  function setScorePanelVisible(){
    const el = document.getElementById("scorePanel");
    if(!el) return;
    el.style.display = (activeTab === "score") ? "block" : "none";
  }

  function getWeights(){
    const wdEl = document.getElementById("wDemand");
    const weEl = document.getElementById("wEquity");
    const wpEl = document.getElementById("wPenalty");

    let wd = wdEl ? num(wdEl.value, W.demand) : W.demand;
    let we = weEl ? num(weEl.value, W.equity) : W.equity;
    let wp = wpEl ? num(wpEl.value, W.penalty) : W.penalty;

    const sumDE = wd + we;
    if(sumDE > 0){
      wd = wd / sumDE;
      we = we / sumDE;
    } else {
      wd = 0.5; we = 0.5;
    }
    return { wd, we, wp };
  }

  function updateWeightUI(){
    const { wd, we, wp } = getWeights();
    const wdVal = document.getElementById("wDemandVal");
    const weVal = document.getElementById("wEquityVal");
    const wpVal = document.getElementById("wPenaltyVal");
    if(wdVal) wdVal.textContent = wd.toFixed(2);
    if(weVal) weVal.textContent = we.toFixed(2);
    if(wpVal) wpVal.textContent = wp.toFixed(2);

    const formula = document.getElementById("scoreFormula");
    if(formula){
      formula.innerHTML =
        `<span class="mono">Score = ${wd.toFixed(2)}·Demand + ${we.toFixed(2)}·Equity − ${wp.toFixed(2)}·Penalty</span>`;
    }
  }

  function renderScoreTab(){
    const scoreList = document.getElementById("scoreList");
    const badge = document.getElementById("scoreCountBadge");
    if(!scoreList || !badge) return;

    if(!selected || selected.length === 0){
      badge.textContent = "0";
      scoreList.innerHTML =
        `<div class="item">
          <div class="itemTitle">No shortlist yet</div>
          <div class="muted">Click <b>Run scenario</b> first, then adjust sliders.</div>
        </div>`;
      document.getElementById("k_davg").textContent = "–";
      document.getElementById("k_eavg").textContent = "–";
      document.getElementById("k_pavg").textContent = "–";
      document.getElementById("k_savg").textContent = "–";
      return;
    }

    badge.textContent = String(selected.length);

    const avg = (arr)=> arr.reduce((a,b)=>a+b,0)/Math.max(1,arr.length);
    const davg = avg(selected.map(x=>num(x.d01,0)));
    const eavg = avg(selected.map(x=>num(x.e01,0)));
    const pavg = avg(selected.map(x=>num(x.p01,0)));
    const savg = avg(selected.map(x=>num(x.score,0)));

    document.getElementById("k_davg").textContent = (davg*100).toFixed(0);
    document.getElementById("k_eavg").textContent = (eavg*100).toFixed(0);
    document.getElementById("k_pavg").textContent = (pavg*100).toFixed(0);
    document.getElementById("k_savg").textContent = savg.toFixed(3);

    scoreList.innerHTML = "";
    selected.forEach((c, idx)=>{
      const div = document.createElement("div");
      div.className = "item";

      const title = document.createElement("div");
      title.className = "itemTitle";
      title.textContent = `${idx+1}. ${c.name || "Candidate"} (score=${c.score.toFixed(3)})`;

      const meta = document.createElement("div");
      meta.className = "itemMeta";
      meta.innerHTML = `
        <span class="badge">D ${(c.d01*100).toFixed(0)}</span>
        <span class="badge">E ${(c.e01*100).toFixed(0)}</span>
        <span class="badge">P ${(c.p01*100).toFixed(0)}</span>
        <span class="badge">LSOA ${escapeHtml(c.lsoaCode || "n/a")}</span>
      `;

      const clampPct = (x)=> Math.max(0, Math.min(100, x*100));
      const bars1 = document.createElement("div");
      bars1.className = "barRow";
      bars1.innerHTML = `
        <span class="tiny" style="width:55px;">Demand</span>
        <div class="barTrack"><div class="barFill" style="width:${clampPct(c.contribDemand)}%; background:#2563eb;"></div></div>
        <span class="tiny mono" style="width:66px; text-align:right;">+${c.contribDemand.toFixed(3)}</span>
      `;
      const bars2 = document.createElement("div");
      bars2.className = "barRow";
      bars2.innerHTML = `
        <span class="tiny" style="width:55px;">Equity</span>
        <div class="barTrack"><div class="barFill" style="width:${clampPct(c.contribEquity)}%; background:#10b981;"></div></div>
        <span class="tiny mono" style="width:66px; text-align:right;">+${c.contribEquity.toFixed(3)}</span>
      `;
      const bars3 = document.createElement("div");
      bars3.className = "barRow";
      bars3.innerHTML = `
        <span class="tiny" style="width:55px;">Penalty</span>
        <div class="barTrack"><div class="barFill" style="width:${clampPct(c.contribPenalty)}%; background:#6b7280;"></div></div>
        <span class="tiny mono" style="width:66px; text-align:right;">−${c.contribPenalty.toFixed(3)}</span>
      `;

      div.appendChild(title);
      div.appendChild(meta);
      div.appendChild(bars1);
      div.appendChild(bars2);
      div.appendChild(bars3);

      div.addEventListener("click", ()=> focusCandidate(c));
      scoreList.appendChild(div);
    });
  }

  // ===============================
  // 6) TABS & CHOROPLETH
  // ===============================
  function setTab(tab){
    activeTab = tab;
    document.getElementById("tabKpi").classList.toggle("active", tab==="kpi");
    document.getElementById("tabGap").classList.toggle("active", tab==="gap");
    document.getElementById("tabScore").classList.toggle("active", tab==="score");

    setScorePanelVisible();
    styleLSOA();

    if(activeTab === "score"){
      updateWeightUI();
      renderScoreTab();
    }
  }

  function styleLSOA(){
    if(!lsoaLayer) return;

    if(activeTab === "gap"){
      lsoaLayer.setStyle((ft)=>{
        const s = num(ft.getProperty("_gapScore"), 0);
        let fill = "#10b981";
        if(s > 0.66) fill = "#f87171";
        else if(s > 0.33) fill = "#f59e0b";
        return {
          fillColor: fill,
          fillOpacity: 0.42,
          strokeColor: "#111827",
          strokeOpacity: 0.75,
          strokeWeight: 2.5
        };
      });
    } else {
      lsoaLayer.setStyle({
        fillColor: "#93c5fd",
        fillOpacity: 0.18,
        strokeColor: "#2563eb",
        strokeOpacity: 0.85,
        strokeWeight: 2.5
      });
    }
  }

  // ===============================
  // 7) GEOMETRY HELPERS
  // ===============================
  function makePolygonsFromGeometry(geom){
    const polys = [];
    if(!geom) return polys;

    const toPath = (ring) => ring.map(([lng,lat]) => ({lat, lng}));
    const buildPoly = (rings) => {
      const paths = rings.map(toPath);
      return new google.maps.Polygon({ paths });
    };

    if(geom.type === "Polygon"){
      polys.push(buildPoly(geom.coordinates));
    } else if(geom.type === "MultiPolygon"){
      for(const poly of geom.coordinates){
        polys.push(buildPoly(poly));
      }
    }
    return polys;
  }

  function containsAny(polys, latLng){
    for(const p of polys){
      if(google.maps.geometry.poly.containsLocation(latLng, p)) return true;
    }
    return false;
  }

  function joinPointToLSOA(latLng){
    for(const rec of lsoaIndex){
      if(containsAny(rec.polygons, latLng)) return rec;
    }
    return null;
  }

  function normalize01(arr){
    let mn=Infinity, mx=-Infinity;
    for(const v of arr){
      if(!Number.isFinite(v)) continue;
      mn=Math.min(mn,v); mx=Math.max(mx,v);
    }
    if(!Number.isFinite(mn) || !Number.isFinite(mx) || mn===mx) return { norm: (_)=>0.5 };
    return { norm: (x)=> (x-mn)/(mx-mn) };
  }

  // ===============================
  // 8) KPI / GAP
  // ===============================
  function computeSupplyTotal(){
    let sum = 0;
    for(const p of supplyPts) sum += num(p.sockets, 0);
    if(sum === 0 && supplyPts.length) sum = supplyPts.length;
    return sum;
  }

  function computeLSOAGapScores(){
    const supplyByLSOA = new Map();
    for(const s of supplyPts){
      const ll = new google.maps.LatLng(s.lat, s.lng);
      const rec = joinPointToLSOA(ll);
      if(!rec) continue;
      const prev = supplyByLSOA.get(rec.code) || 0;
      supplyByLSOA.set(rec.code, prev + num(s.sockets, 1));
    }

    const demandArr = [];
    const supplyArr = [];

    for(const rec of lsoaIndex){
      const sup = supplyByLSOA.get(rec.code) || 0;
      rec.supplyRaw = sup;
      demandArr.push(num(rec.demandRaw, 0));
      supplyArr.push(num(rec.supplyRaw, 0));
    }

    const nd = normalize01(demandArr);
    const ns = normalize01(supplyArr);

    for(const rec of lsoaIndex){
      if(!rec.feature) continue;
      const d01 = nd.norm(num(rec.demandRaw, 0));
      const s01 = ns.norm(num(rec.supplyRaw, 0));
      const g = Math.max(0, Math.min(1, d01 - 0.7*s01));
      rec.feature.setProperty("_gapScore", g);
    }
  }

  // ===============================
  // 9) SELECTION + UI LIST
  // ===============================
  function updateSelectedLayer(){
    selectedLayer.forEach(ft=> selectedLayer.remove(ft));
    const fc = {
      type:"FeatureCollection",
      features: selected.map((c, i)=>({
        type:"Feature",
        geometry:{ type:"Point", coordinates:[c.lng, c.lat] },
        properties:{
          rank:i+1,
          name:c.name||"Selected",
          score:c.score,
          demand01:c.d01,
          equity01:c.e01,
          penalty01:c.p01,
          lsoa:c.lsoaCode||"",
          population: c.pop ?? null,
          median_age: c.medianAge ?? null
        }
      }))
    };
    selectedLayer.addGeoJson(fc);
  }

  function focusCandidate(c){
    map.panTo({lat:c.lat, lng:c.lng});
    map.setZoom(Math.max(map.getZoom(), 14));

    const pct = (x)=> Number.isFinite(x) ? Math.round(x*100) : null;

    // show key proxies if available
    const badges = [];
    if(Number.isFinite(c.parking_constraint)) badges.push(`parking_constraint ${c.parking_constraint.toFixed(2)}`);
    if(Number.isFinite(c.share_flats)) badges.push(`share_flats ${Math.round(c.share_flats*100)}%`);
    if(Number.isFinite(c.share_dense)) badges.push(`share_dense ${Math.round(c.share_dense*100)}%`);
    if(Number.isFinite(c.share_rented)) badges.push(`share_rented ${Math.round(c.share_rented*100)}%`);
    if(Number.isFinite(c.share_no_car)) badges.push(`share_no_car ${Math.round(c.share_no_car*100)}%`);
    if(Number.isFinite(c.wimd_rank)) badges.push(`wimd_rank ${Math.round(c.wimd_rank)}`);
    if(Number.isFinite(c.wimd_decile)) badges.push(`wimd_decile ${Math.round(c.wimd_decile)}`);

    info.setContent(
      `<b>${escapeHtml(c.name||"Selected")}</b><br/>` +
      `Score: ${escapeHtml(c.score.toFixed(3))}<br/>` +
      `Demand: ${pct(c.d01)} | Equity: ${pct(c.e01)} | Penalty: ${pct(c.p01)}<br/>` +
      `LSOA: ${escapeHtml(c.lsoaCode||"n/a")}<br/>` +
      `Population: ${Number.isFinite(c.pop)? Math.round(c.pop): "n/a"}<br/>` +
      `Median age: ${Number.isFinite(c.medianAge)? c.medianAge.toFixed(1): "n/a"}<br/>` +
      (badges.length ? `<div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">${badges.map(b=>`<span class="badge">${escapeHtml(b)}</span>`).join("")}</div>` : "")
    );
    info.setPosition({lat:c.lat, lng:c.lng});
    info.open({map});
  }

  function renderList(){
    const list = document.getElementById("resultList");
    const empty = document.getElementById("emptyHint");
    const badge = document.getElementById("countBadge");
    badge.textContent = String(selected.length);

    if(!selected.length){
      list.style.display="none";
      empty.style.display="block";
      return;
    }
    empty.style.display="none";
    list.style.display="block";
    list.innerHTML="";

    selected.forEach((c, idx)=>{
      const div = document.createElement("div");
      div.className="item";

      const t = document.createElement("div");
      t.className="itemTitle";
      t.textContent = `${idx+1}. ${c.name || "Candidate"}`;

      // show some proxies in the list (nice for demos)
      const metaBadges = [];
      metaBadges.push(`<span class="badge">Score: ${escapeHtml(c.score.toFixed(3))}</span>`);
      metaBadges.push(`<span class="badge">D ${Math.round(c.d01*100)}</span>`);
      metaBadges.push(`<span class="badge">E ${Math.round(c.e01*100)}</span>`);
      metaBadges.push(`<span class="badge">P ${Math.round(c.p01*100)}</span>`);
      metaBadges.push(`<span class="badge">LSOA: ${escapeHtml(c.lsoaCode || "n/a")}</span>`);
      if(Number.isFinite(c.parking_constraint)) metaBadges.push(`<span class="badge">ParkC: ${c.parking_constraint.toFixed(2)}</span>`);
      if(Number.isFinite(c.share_no_car)) metaBadges.push(`<span class="badge">NoCar: ${Math.round(c.share_no_car*100)}%</span>`);

      const m = document.createElement("div");
      m.className="itemMeta";
      m.innerHTML = metaBadges.join("");

      div.appendChild(t);
      div.appendChild(m);

      div.addEventListener("click", ()=> focusCandidate(c));
      list.appendChild(div);
    });
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href=url; a.download=filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 800);
  }

  function exportCSV(){
    const rows = [["rank","name","lat","lng","score","demand01","equity01","penalty01","lsoa","population","median_age",
                   "parking_constraint","share_flats","share_dense","share_rented","share_no_car","wimd_rank","wimd_decile","wimd_norm"]];
    selected.forEach((c,i)=>{
      rows.push([
        i+1,
        (c.name||"").replaceAll('"','""'),
        c.lat,
        c.lng,
        c.score.toFixed(6),
        c.d01.toFixed(6),
        c.e01.toFixed(6),
        c.p01.toFixed(6),
        c.lsoaCode||"",
        Number.isFinite(c.pop)? Math.round(c.pop): "",
        Number.isFinite(c.medianAge)? c.medianAge: "",
        Number.isFinite(c.parking_constraint)? c.parking_constraint.toFixed(4): "",
        Number.isFinite(c.share_flats)? c.share_flats.toFixed(4): "",
        Number.isFinite(c.share_dense)? c.share_dense.toFixed(4): "",
        Number.isFinite(c.share_rented)? c.share_rented.toFixed(4): "",
        Number.isFinite(c.share_no_car)? c.share_no_car.toFixed(4): "",
        Number.isFinite(c.wimd_rank)? Math.round(c.wimd_rank): "",
        Number.isFinite(c.wimd_decile)? Math.round(c.wimd_decile): "",
        Number.isFinite(c.wimd_norm)? c.wimd_norm.toFixed(6): ""
      ]);
    });
    const csv = rows.map(r=> r.map(x=> `"${x}"`).join(",")).join("\n");
    downloadText("planner_shortlist.csv", csv);
  }

  function exportGeoJSON(){
    const fc = {
      type:"FeatureCollection",
      features: selected.map((c,i)=>({
        type:"Feature",
        geometry:{type:"Point", coordinates:[c.lng,c.lat]},
        properties:{
          rank:i+1,
          name:c.name||"",
          score:+c.score.toFixed(6),
          demand01:+c.d01.toFixed(6),
          equity01:+c.e01.toFixed(6),
          penalty01:+c.p01.toFixed(6),
          lsoa:c.lsoaCode||"",
          population: Number.isFinite(c.pop)? Math.round(c.pop): null,
          median_age: Number.isFinite(c.medianAge)? +c.medianAge.toFixed(1): null,

          parking_constraint: Number.isFinite(c.parking_constraint)? +c.parking_constraint.toFixed(4): null,
          share_flats: Number.isFinite(c.share_flats)? +c.share_flats.toFixed(4): null,
          share_dense: Number.isFinite(c.share_dense)? +c.share_dense.toFixed(4): null,
          share_rented: Number.isFinite(c.share_rented)? +c.share_rented.toFixed(4): null,
          share_no_car: Number.isFinite(c.share_no_car)? +c.share_no_car.toFixed(4): null,
          wimd_rank: Number.isFinite(c.wimd_rank)? Math.round(c.wimd_rank): null,
          wimd_decile: Number.isFinite(c.wimd_decile)? Math.round(c.wimd_decile): null,
          wimd_norm: Number.isFinite(c.wimd_norm)? +c.wimd_norm.toFixed(6): null
        }
      }))
    };
    downloadText("planner_shortlist.geojson", JSON.stringify(fc, null, 2));
  }

  // ===============================
  // 10) SCENARIO RUN (TOP P)
  // ===============================
  function runScenario(){
    const P = Math.max(1, Math.floor(num(document.getElementById("pSel").value, 10)));
    const year = String(document.getElementById("yearSel").value || "2030");
    const target = num(TARGET_BY_YEAR[year], 1500);

    const supplyTotal = computeSupplyTotal();
    const gap = Math.max(0, target - supplyTotal);

    document.getElementById("k_supply").textContent = String(Math.round(supplyTotal));
    document.getElementById("k_target").textContent = String(Math.round(target));
    document.getElementById("k_gap").textContent = String(Math.round(gap));

    if(!candPts.length){
      setStatus("No candidates loaded. Check demand_points_cardiff_exact_pop_wgs84.geojson path.");
      return;
    }

    const dN = normalize01(candPts.map(c=>c.demandRaw));
    const eN = normalize01(candPts.map(c=>c.equityRaw));
    const pN = normalize01(candPts.map(c=>c.penaltyRaw));

    const { wd, we, wp } = getWeights();

    for(const c of candPts){
      c.d01 = dN.norm(num(c.demandRaw, 0));
      c.e01 = eN.norm(num(c.equityRaw, 0));
      c.p01 = pN.norm(num(c.penaltyRaw, 0));

      c.score = wd*c.d01 + we*c.e01 - wp*c.p01;
      c.contribDemand = wd*c.d01;
      c.contribEquity = we*c.e01;
      c.contribPenalty = wp*c.p01;
    }

    candPts.sort((a,b)=> b.score - a.score);
    selected = candPts.slice(0, P);

    updateSelectedLayer();
    renderList();

    document.getElementById("k_selected").textContent = String(selected.length);
    document.getElementById("btnExportCsv").disabled = selected.length===0;
    document.getElementById("btnExportGeo").disabled = selected.length===0;

    computeLSOAGapScores();
    styleLSOA();

    updateWeightUI();
    if(activeTab === "score") renderScoreTab();

    setStatus(
      `Scenario done.\n` +
      `Year=${year}, target=${Math.round(target)}, supply=${Math.round(supplyTotal)}, gap=${Math.round(gap)}.\n` +
      `Candidates=${candPts.length}, selected Top ${selected.length}.\n` +
      `Demand(population) + Equity(WIMD) - Penalty(parking_constraint/proxies).\n` +
      `Switch to "Gap map" tab for underserved areas.`
    );
  }

  // ===============================
  // 11) MAP INIT
  // ===============================
  async function initMap(){
    map = new google.maps.Map(document.getElementById("map"), {
      center:{lat:51.4816,lng:-3.1791},
      zoom:12,
      mapTypeControl:false, streetViewControl:false, fullscreenControl:true
    });
    info = new google.maps.InfoWindow();

    supplyLayer   = new google.maps.Data({map});
    lsoaLayer     = new google.maps.Data({map});
    candLayer     = new google.maps.Data({map});
    selectedLayer = new google.maps.Data({map});
    solutionLayer = new google.maps.Data({map});

    // Make existing chargers more visible (bigger radius + thicker white stroke)
    supplyLayer.setStyle(()=>({ icon: iconCircle("#2563eb", 8, 4), zIndex: 800 }));
    candLayer.setStyle(()=>({ icon: iconCircle("#f59e0b", 6, 2), zIndex: 700 }));
    selectedLayer.setStyle(()=>({ icon: iconStar("#ef4444"), zIndex: 9999 }));
    solutionLayer.setStyle(()=>({ icon: iconTriangle("#7c3aed"), zIndex: 850 }));

    styleLSOA();
    setScorePanelVisible();
    updateWeightUI();

    // Hide p10 UI if disabled
    if(!ENABLE_P10_OVERLAY){
      const wrap = document.getElementById("ckSolutionWrap");
      if(wrap) wrap.style.display = "none";
    }

    // UI toggles
    document.getElementById("ckSupply").addEventListener("change",(e)=> supplyLayer.setMap(e.target.checked? map:null));
    document.getElementById("ckLSOA").addEventListener("change",(e)=> lsoaLayer.setMap(e.target.checked? map:null));
    document.getElementById("ckCandidates").addEventListener("change",(e)=> candLayer.setMap(e.target.checked? map:null));
    document.getElementById("ckSelected").addEventListener("change",(e)=> selectedLayer.setMap(e.target.checked? map:null));
    const ckSol = document.getElementById("ckSolution");
    if(ckSol){
      ckSol.addEventListener("change",(e)=> solutionLayer.setMap(e.target.checked? map:null));
    }

    document.getElementById("tabKpi").addEventListener("click",()=>setTab("kpi"));
    document.getElementById("tabGap").addEventListener("click",()=>setTab("gap"));
    document.getElementById("tabScore").addEventListener("click",()=>setTab("score"));

    document.getElementById("btnRun").addEventListener("click", runScenario);
    document.getElementById("btnExportCsv").addEventListener("click", exportCSV);
    document.getElementById("btnExportGeo").addEventListener("click", exportGeoJSON);
    document.getElementById("btnPrint").addEventListener("click", ()=>window.print());

    // sliders -> auto re-run scenario
    function hookSlider(id){
      const el = document.getElementById(id);
      if(!el) return;
      el.addEventListener("input", ()=>{
        updateWeightUI();
        if(Array.isArray(candPts) && candPts.length > 0) runScenario();
      });
    }
    hookSlider("wDemand");
    hookSlider("wEquity");
    hookSlider("wPenalty");

    try{
      setStatus("Loading GeoJSON…");

      const [supply, lsoa, candidates] = await Promise.all([
        loadGeoJSON(DATA_URLS.supply),
        loadGeoJSON(DATA_URLS.lsoa),
        loadGeoJSON(DATA_URLS.candidates)
      ]);

      const solution = ENABLE_P10_OVERLAY ? await loadGeoJSONOptional(DATA_URLS.solution) : null;

      supplyLayer.addGeoJson(supply);
      lsoaLayer.addGeoJson(lsoa);
      candLayer.addGeoJson(candidates);
      if(solution) solutionLayer.addGeoJson(solution);
      if(!ENABLE_P10_OVERLAY) solutionLayer.setMap(null);

      // build LSOA index from enriched geojson polygons
      lsoaIndex = (lsoa.features||[]).map((f)=>{
        const props = f.properties || {};
        const code = getProp(props, FIELD.code, "LSOA");

        // Demand raw: population preferred
        const pop  = num(getProp(props, FIELD.pop, null), NaN);
        const demandRaw = Number.isFinite(pop) ? pop : num(getProp(props, FIELD.demand, 1), 1);

        // Equity raw: WIMD preferred
        const medAge = num(getProp(props, FIELD.median_age, null), NaN);
        const equityRaw = computeEquityFromProps(props, medAge);

        // Penalty raw: parking_constraint or derived shares
        const penaltyRaw = computePenaltyFromProps(props);

        // Store useful proxies for popups/list
        const wimd_norm   = num(getProp(props, FIELD.wimd_norm, NaN), NaN);
        const wimd_rank   = num(getProp(props, FIELD.wimd_rank, NaN), NaN);
        const wimd_decile = num(getProp(props, FIELD.wimd_decile, NaN), NaN);

        const parking_constraint = pctTo01(getProp(props, FIELD.parking_constraint, NaN));
        const share_flats  = pctTo01(getProp(props, FIELD.share_flats, NaN));
        const share_dense  = pctTo01(getProp(props, FIELD.share_dense, NaN));
        const share_rented = pctTo01(getProp(props, FIELD.share_rented, NaN));
        const share_no_car = pctTo01(getProp(props, FIELD.share_no_car, NaN));

        const polygons = makePolygonsFromGeometry(f.geometry);

        return {
          code,
          pop,
          medianAge: medAge,
          demandRaw,
          equityRaw,
          penaltyRaw,
          wimd_norm, wimd_rank, wimd_decile,
          parking_constraint, share_flats, share_dense, share_rented, share_no_car,
          polygons,
          feature: null,
          supplyRaw: 0
        };
      });

      // Map Data layer features back to index so we can set _gapScore
      const lsoaByCode = new Map(lsoaIndex.map(r=>[r.code, r]));
      lsoaLayer.forEach((ft)=>{
        const propsLike = {
          LSOA21CD: ft.getProperty("LSOA21CD"),
          lsoa21cd: ft.getProperty("lsoa21cd"),
          LSOA11CD: ft.getProperty("LSOA11CD"),
          lsoa11cd: ft.getProperty("lsoa11cd"),
          code: ft.getProperty("code"),
          id: ft.getProperty("id"),
        };
        const code = getProp(propsLike, FIELD.code, null);
        if(code && lsoaByCode.has(code)){
          const rec = lsoaByCode.get(code);
          rec.feature = ft;
          ft.setProperty("code", rec.code);
        }
      });

      // supply cache
      supplyPts = [];
      for(const f of (supply.features||[])){
        if(!f.geometry || f.geometry.type!=="Point") continue;
        const [lng, lat] = f.geometry.coordinates || [];
        if(typeof lat!=="number" || typeof lng!=="number") continue;
        if(looksLike27700(lng, lat)) continue;
        const props = f.properties || {};
        const sockets = num(getProp(props, FIELD.sockets, 0), 0);
        supplyPts.push({lat,lng,sockets: sockets || 1});
      }

      // candidate cache + join to enriched LSOA (inherit demand/equity/penalty + proxies)
      candPts = [];
      for(const f of (candidates.features||[])){
        if(!f.geometry || f.geometry.type!=="Point") continue;
        const [lng, lat] = f.geometry.coordinates || [];
        if(typeof lat!=="number" || typeof lng!=="number") continue;
        if(looksLike27700(lng, lat)) continue;

        const props = f.properties || {};
        const name = getProp(props, ["name","id","site","label","LSOA21NM","LSOA11NM"], "Demand centroid");

        const ll = new google.maps.LatLng(lat, lng);
        const rec = joinPointToLSOA(ll);

        const demandRaw = rec ? num(rec.demandRaw, 1) : 1;
        const equityRaw = rec ? num(rec.equityRaw, 0) : 0;
        const penaltyRaw = rec ? num(rec.penaltyRaw, 0) : 0;

        const pop = rec ? num(rec.pop, NaN) : NaN;
        const medianAge = rec ? num(rec.medianAge, NaN) : NaN;

        candPts.push({
          lat,lng,name,
          demandRaw, equityRaw, penaltyRaw,
          lsoaCode: rec ? rec.code : "",
          pop, medianAge,

          // proxies for info window / export
          wimd_norm: rec ? rec.wimd_norm : NaN,
          wimd_rank: rec ? rec.wimd_rank : NaN,
          wimd_decile: rec ? rec.wimd_decile : NaN,
          parking_constraint: rec ? rec.parking_constraint : NaN,
          share_flats: rec ? rec.share_flats : NaN,
          share_dense: rec ? rec.share_dense : NaN,
          share_rented: rec ? rec.share_rented : NaN,
          share_no_car: rec ? rec.share_no_car : NaN
        });
      }

      // initial KPI
      const year = String(document.getElementById("yearSel").value || "2030");
      const supplyTotal = computeSupplyTotal();
      document.getElementById("k_supply").textContent = String(Math.round(supplyTotal));
      document.getElementById("k_target").textContent = String(Math.round(num(TARGET_BY_YEAR[year], 1500)));
      document.getElementById("k_gap").textContent = "–";

      map.fitBounds(CARDIFF_BOUNDS);

      setStatus(
        `Loaded.\n` +
        `Supply points: ${supplyPts.length}\n` +
        `LSOA polygons (enriched): ${(lsoa.features||[]).length}\n` +
        `Candidates: ${candPts.length}\n` +
        `p10 overlay: ${ENABLE_P10_OVERLAY && solution ? "loaded" : "disabled"}\n\n` +
        `Next: Run scenario (Top P) → then open Scoring tab.`
      );

    } catch(err){
      console.error(err);
      setStatus("FAILED.\n" + String(err));
      alert(String(err));
    }
  }

  window.initMap = initMap;

  (function loadGoogleMaps(){
    const s = document.createElement("script");
    // add loading=async to reduce the warning
    s.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(GMAPS_KEY)}&callback=initMap&v=weekly&libraries=geometry&loading=async`;
    s.async = true; s.defer = true;
    document.head.appendChild(s);
  })();
</script>
</body>
</html>
